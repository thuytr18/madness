<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MADNESS: Serialization</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MADNESS
   &#160;<span id="projectnumber">0.10.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Serialization<div class="ingroups"><a class="el" href="group__libraries.html">MADNESS libraries</a> &raquo; <a class="el" href="group__parallel__runtime.html">Parallel programming environment</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Serialization:</div>
<div class="dyncontent">
<div class="center"><img src="group__serialization.png" border="0" usemap="#agroup____serialization" alt=""/></div>
<map name="agroup____serialization" id="agroup____serialization">
<area shape="rect" href="group__parallel__runtime.html" title=" " alt="" coords="5,5,168,45"/>
<area shape="rect" title=" " alt="" coords="216,13,319,38"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:archive_8cc"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="archive_8cc.html">archive.cc</a></td></tr>
<tr class="memdesc:archive_8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions of serialization functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:archive_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="archive_8h.html">archive.h</a></td></tr>
<tr class="memdesc:archive_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface templates for the archives (serialization). <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:archive__type__names_8cc"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="archive__type__names_8cc.html">archive_type_names.cc</a></td></tr>
<tr class="memdesc:archive__type__names_8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines archive type names for supported (by default) types. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:binary__fstream__archive_8cc"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binary__fstream__archive_8cc.html">binary_fstream_archive.cc</a></td></tr>
<tr class="memdesc:binary__fstream__archive_8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements an archive wrapping a binary filestream. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:binary__fstream__archive_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binary__fstream__archive_8h.html">binary_fstream_archive.h</a></td></tr>
<tr class="memdesc:binary__fstream__archive_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements an archive wrapping a binary filestream. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:buffer__archive_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer__archive_8h.html">buffer_archive.h</a></td></tr>
<tr class="memdesc:buffer__archive_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements an archive wrapping a memory buffer. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:mpi__archive_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpi__archive_8h.html">mpi_archive.h</a></td></tr>
<tr class="memdesc:mpi__archive_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements archives to serialize data for MPI. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:parallel__archive_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parallel__archive_8h.html">parallel_archive.h</a></td></tr>
<tr class="memdesc:parallel__archive_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <code>ParallelInputArchive</code> and <code>ParallelOutputArchive</code> for parallel serialization of data. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:text__fstream__archive_8cc"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="text__fstream__archive_8cc.html">text_fstream_archive.cc</a></td></tr>
<tr class="memdesc:text__fstream__archive_8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements an archive wrapping text filestream. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:text__fstream__archive_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="text__fstream__archive_8h.html">text_fstream_archive.h</a></td></tr>
<tr class="memdesc:text__fstream__archive_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements an archive wrapping text filestream. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:vector__archive_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vector__archive_8h.html">vector_archive.h</a></td></tr>
<tr class="memdesc:vector__archive_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements an archive wrapping an STL <code>vector</code>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmadness_1_1archive_1_1archive__array.html">madness::archive::archive_array&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for dynamic arrays and pointers.  <a href="classmadness_1_1archive_1_1archive__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmadness_1_1archive_1_1archive__ptr.html">madness::archive::archive_ptr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for an opaque pointer for serialization purposes.  <a href="classmadness_1_1archive_1_1archive__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1archive__typeinfo.html">madness::archive::archive_typeinfo&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to enable type checking inside archives.  <a href="structmadness_1_1archive_1_1archive__typeinfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1ArchiveImpl.html">madness::archive::ArchiveImpl&lt; Archive, T, Enabler &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementations of <code>wrap_store</code> and <code>wrap_load</code>.  <a href="structmadness_1_1archive_1_1ArchiveImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1ArchiveImpl_3_01Archive_00_01archive__array_3_01T_01_4_01_4.html">madness::archive::ArchiveImpl&lt; Archive, archive_array&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialization of <code><a class="el" href="structmadness_1_1archive_1_1ArchiveImpl.html" title="Default implementations of wrap_store and wrap_load.">ArchiveImpl</a></code> for <code><a class="el" href="classmadness_1_1archive_1_1archive__array.html" title="Wrapper for dynamic arrays and pointers.">archive_array</a></code>.  <a href="structmadness_1_1archive_1_1ArchiveImpl_3_01Archive_00_01archive__array_3_01T_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1ArchiveImpl_3_01Archive_00_01T_0fn_0e_00_01std_1_1enable__if__t_3_9s63db41161ad0bf40e662a0bd8965027e.html">madness::archive::ArchiveImpl&lt; Archive, T[n], std::enable_if_t&lt;!std::is_same_v&lt; T, char &gt; &amp;&amp;is_serializable_v&lt; Archive, T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialization of <code><a class="el" href="structmadness_1_1archive_1_1ArchiveImpl.html" title="Default implementations of wrap_store and wrap_load.">ArchiveImpl</a></code> for fixed-dimension arrays that redirects to <code><a class="el" href="classmadness_1_1archive_1_1archive__array.html" title="Wrapper for dynamic arrays and pointers.">archive_array</a></code>.  <a href="structmadness_1_1archive_1_1ArchiveImpl_3_01Archive_00_01T_0fn_0e_00_01std_1_1enable__if__t_3_9s63db41161ad0bf40e662a0bd8965027e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1ArchiveImpl_3_01ParallelInputArchive_3_01localarchiveT_01_4_00_01archive__array_3_01T_01_4_01_4.html">madness::archive::ArchiveImpl&lt; ParallelInputArchive&lt; localarchiveT &gt;, archive_array&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the archive array and broadcast.  <a href="structmadness_1_1archive_1_1ArchiveImpl_3_01ParallelInputArchive_3_01localarchiveT_01_4_00_01archive__array_3_01T_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1ArchiveImpl_3_01ParallelInputArchive_3_01localarchiveT_01_4_00_01T_01_4.html">madness::archive::ArchiveImpl&lt; ParallelInputArchive&lt; localarchiveT &gt;, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <code><a class="el" href="structmadness_1_1archive_1_1ArchiveImpl.html" title="Default implementations of wrap_store and wrap_load.">ArchiveImpl</a></code> for parallel input archives.  <a href="structmadness_1_1archive_1_1ArchiveImpl_3_01ParallelInputArchive_3_01localarchiveT_01_4_00_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1ArchiveImpl_3_01ParallelInputArchive_3_01localarchiveT_01_4_00_01T_0fn_0e_4.html">madness::archive::ArchiveImpl&lt; ParallelInputArchive&lt; localarchiveT &gt;, T[n]&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward a fixed-size array to <code><a class="el" href="classmadness_1_1archive_1_1archive__array.html" title="Wrapper for dynamic arrays and pointers.">archive_array</a></code>.  <a href="structmadness_1_1archive_1_1ArchiveImpl_3_01ParallelInputArchive_3_01localarchiveT_01_4_00_01T_0fn_0e_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1ArchiveImpl_3_01ParallelOutputArchive_3_01localarchiveT_01_4_00_01archive__array_3_01T_01_4_01_4.html">madness::archive::ArchiveImpl&lt; ParallelOutputArchive&lt; localarchiveT &gt;, archive_array&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the archive array only from process zero.  <a href="structmadness_1_1archive_1_1ArchiveImpl_3_01ParallelOutputArchive_3_01localarchiveT_01_4_00_01archive__array_3_01T_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1ArchiveImpl_3_01ParallelOutputArchive_3_01localarchiveT_01_4_00_01T_01_4.html">madness::archive::ArchiveImpl&lt; ParallelOutputArchive&lt; localarchiveT &gt;, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <code><a class="el" href="structmadness_1_1archive_1_1ArchiveImpl.html" title="Default implementations of wrap_store and wrap_load.">ArchiveImpl</a></code> for parallel output archives.  <a href="structmadness_1_1archive_1_1ArchiveImpl_3_01ParallelOutputArchive_3_01localarchiveT_01_4_00_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1ArchiveImpl_3_01ParallelOutputArchive_3_01localarchiveT_01_4_00_01T_0fn_0e_4.html">madness::archive::ArchiveImpl&lt; ParallelOutputArchive&lt; localarchiveT &gt;, T[n]&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward a fixed-size array to <code><a class="el" href="classmadness_1_1archive_1_1archive__array.html" title="Wrapper for dynamic arrays and pointers.">archive_array</a></code>.  <a href="structmadness_1_1archive_1_1ArchiveImpl_3_01ParallelOutputArchive_3_01localarchiveT_01_4_00_01T_0fn_0e_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1ArchiveLoadImpl.html">madness::archive::ArchiveLoadImpl&lt; Archive, T, Enabler &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default load of an object via <code>serialize(ar, t)</code>.  <a href="structmadness_1_1archive_1_1ArchiveLoadImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1ArchiveLoadImpl_3_01Archive_00_01std_1_1allocator_3_01T_01_4_00_01st681c848fc106cc47e6d3ff1415943c61.html">madness::archive::ArchiveLoadImpl&lt; Archive, std::allocator&lt; T &gt;, std::enable_if_t&lt;!is_future&lt; T &gt;::value &amp;&amp;is_serializable_v&lt; Archive, T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize a <code>std::allocator</code>.  <a href="structmadness_1_1archive_1_1ArchiveLoadImpl_3_01Archive_00_01std_1_1allocator_3_01T_01_4_00_01st681c848fc106cc47e6d3ff1415943c61.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1ArchiveLoadImpl_3_01Archive_00_01std_1_1array_3_01T_00_01N_01_4_00_0c286aaa6f2fe5e84dd10b01e3e3fc600.html">madness::archive::ArchiveLoadImpl&lt; Archive, std::array&lt; T, N &gt;, std::enable_if_t&lt; is_serializable_v&lt; Archive, T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize a <code>std::array</code>. <code>MADNESS_ASSERT</code> 's that the size matches.  <a href="structmadness_1_1archive_1_1ArchiveLoadImpl_3_01Archive_00_01std_1_1array_3_01T_00_01N_01_4_00_0c286aaa6f2fe5e84dd10b01e3e3fc600.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1ArchiveLoadImpl_3_01Archive_00_01std_1_1complex_3_01T_01_4_00_01std_5e44588d32f93018fe3f11eda0ee99aa.html">madness::archive::ArchiveLoadImpl&lt; Archive, std::complex&lt; T &gt;, std::enable_if_t&lt; is_serializable_v&lt; Archive, T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize a complex number.  <a href="structmadness_1_1archive_1_1ArchiveLoadImpl_3_01Archive_00_01std_1_1complex_3_01T_01_4_00_01std_5e44588d32f93018fe3f11eda0ee99aa.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1ArchiveLoadImpl_3_01Archive_00_01std_1_1list_3_01T_00_01Alloc_01_4_0fa51e67ee89b592c28e089f02458fa8f.html">madness::archive::ArchiveLoadImpl&lt; Archive, std::list&lt; T, Alloc &gt;, std::enable_if_t&lt;!is_future&lt; T &gt;::value &amp;&amp;is_serializable_v&lt; Archive, T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize a <code>std::list</code>. Clears and resizes as necessary.  <a href="structmadness_1_1archive_1_1ArchiveLoadImpl_3_01Archive_00_01std_1_1list_3_01T_00_01Alloc_01_4_0fa51e67ee89b592c28e089f02458fa8f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1ArchiveLoadImpl_3_01Archive_00_01std_1_1map_3_01T_00_01Q_00_01Compard1423884bda614071362cfbd0ba3cf9b.html">madness::archive::ArchiveLoadImpl&lt; Archive, std::map&lt; T, Q, Compare, Alloc &gt;, std::enable_if_t&lt; is_serializable_v&lt; Archive, T &gt; &amp;&amp;is_serializable_v&lt; Archive, Q &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize an <code>std::map</code>. The <code>map</code> is <em>not</em> cleared; duplicate elements are replaced.  <a href="structmadness_1_1archive_1_1ArchiveLoadImpl_3_01Archive_00_01std_1_1map_3_01T_00_01Q_00_01Compard1423884bda614071362cfbd0ba3cf9b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1ArchiveLoadImpl_3_01Archive_00_01std_1_1set_3_01T_00_01Compare_00_01ef2ee388a909e4c7efa999be8a7f9953.html">madness::archive::ArchiveLoadImpl&lt; Archive, std::set&lt; T, Compare, Alloc &gt;, std::enable_if_t&lt;!is_future&lt; T &gt;::value &amp;&amp;is_serializable_v&lt; Archive, T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize a <code>std::set</code>. Clears and resizes as necessary.  <a href="structmadness_1_1archive_1_1ArchiveLoadImpl_3_01Archive_00_01std_1_1set_3_01T_00_01Compare_00_01ef2ee388a909e4c7efa999be8a7f9953.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1ArchiveLoadImpl_3_01Archive_00_01std_1_1string_01_4.html">madness::archive::ArchiveLoadImpl&lt; Archive, std::string &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize a std::string. Clears and resizes as necessary.  <a href="structmadness_1_1archive_1_1ArchiveLoadImpl_3_01Archive_00_01std_1_1string_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1ArchiveLoadImpl_3_01Archive_00_01std_1_1vector_3_01bool_00_01Alloc_01_4_01_4.html">madness::archive::ArchiveLoadImpl&lt; Archive, std::vector&lt; bool, Alloc &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize a std::vector&lt;bool&gt;. Clears and resizes as necessary.  <a href="structmadness_1_1archive_1_1ArchiveLoadImpl_3_01Archive_00_01std_1_1vector_3_01bool_00_01Alloc_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1ArchiveLoadImpl_3_01Archive_00_01std_1_1vector_3_01T_00_01Alloc_01_446482a1a3f2a11a7ba932d35f7dc061b.html">madness::archive::ArchiveLoadImpl&lt; Archive, std::vector&lt; T, Alloc &gt;, std::enable_if_t&lt;!is_future&lt; T &gt;::value &amp;&amp;is_serializable_v&lt; Archive, T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize a <code>std::vector</code>. Clears and resizes as necessary.  <a href="structmadness_1_1archive_1_1ArchiveLoadImpl_3_01Archive_00_01std_1_1vector_3_01T_00_01Alloc_01_446482a1a3f2a11a7ba932d35f7dc061b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1ArchivePrePostImpl.html">madness::archive::ArchivePrePostImpl&lt; Archive, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the pre/postamble for type checking.  <a href="structmadness_1_1archive_1_1ArchivePrePostImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1ArchivePrePostImpl_3_01BufferInputArchive_00_01T_01_4.html">madness::archive::ArchivePrePostImpl&lt; BufferInputArchive, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement pre/postamble load routines for a <code><a class="el" href="classmadness_1_1archive_1_1BufferInputArchive.html" title="Wraps an archive around a memory buffer for input.">BufferInputArchive</a></code>.  <a href="structmadness_1_1archive_1_1ArchivePrePostImpl_3_01BufferInputArchive_00_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1ArchivePrePostImpl_3_01BufferOutputArchive_00_01T_01_4.html">madness::archive::ArchivePrePostImpl&lt; BufferOutputArchive, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement pre/postamble storage routines for a <code><a class="el" href="classmadness_1_1archive_1_1BufferOutputArchive.html" title="Wraps an archive around a memory buffer for output.">BufferOutputArchive</a></code>.  <a href="structmadness_1_1archive_1_1ArchivePrePostImpl_3_01BufferOutputArchive_00_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1ArchivePrePostImpl_3_01MPIInputArchive_00_01T_01_4.html">madness::archive::ArchivePrePostImpl&lt; MPIInputArchive, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of functions for loading the pre/postamble in MPI archives.  <a href="structmadness_1_1archive_1_1ArchivePrePostImpl_3_01MPIInputArchive_00_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1ArchivePrePostImpl_3_01MPIOutputArchive_00_01T_01_4.html">madness::archive::ArchivePrePostImpl&lt; MPIOutputArchive, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of functions for storing the pre/postamble in MPI archives.  <a href="structmadness_1_1archive_1_1ArchivePrePostImpl_3_01MPIOutputArchive_00_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1ArchivePrePostImpl_3_01MPIRawInputArchive_00_01T_01_4.html">madness::archive::ArchivePrePostImpl&lt; MPIRawInputArchive, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of functions for loading the pre/postamble in MPI archives.  <a href="structmadness_1_1archive_1_1ArchivePrePostImpl_3_01MPIRawInputArchive_00_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1ArchivePrePostImpl_3_01MPIRawOutputArchive_00_01T_01_4.html">madness::archive::ArchivePrePostImpl&lt; MPIRawOutputArchive, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of functions for storing the pre/postamble in MPI archives.  <a href="structmadness_1_1archive_1_1ArchivePrePostImpl_3_01MPIRawOutputArchive_00_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1ArchivePrePostImpl_3_01ParallelInputArchive_3_01localarchiveT_01_4_00_01T_01_4.html">madness::archive::ArchivePrePostImpl&lt; ParallelInputArchive&lt; localarchiveT &gt;, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable type info for parallel input archives.  <a href="structmadness_1_1archive_1_1ArchivePrePostImpl_3_01ParallelInputArchive_3_01localarchiveT_01_4_00_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1ArchivePrePostImpl_3_01ParallelOutputArchive_3_01localarchiveT_01_4_00_01T_01_4.html">madness::archive::ArchivePrePostImpl&lt; ParallelOutputArchive&lt; localarchiveT &gt;, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable type info for parallel output archives.  <a href="structmadness_1_1archive_1_1ArchivePrePostImpl_3_01ParallelOutputArchive_3_01localarchiveT_01_4_00_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1ArchivePrePostImpl_3_01TextFstreamInputArchive_00_01T_01_4.html">madness::archive::ArchivePrePostImpl&lt; TextFstreamInputArchive, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement pre/postamble load routines for a <code><a class="el" href="classmadness_1_1archive_1_1TextFstreamInputArchive.html" title="Wraps an archive around a text filestream for input.">TextFstreamInputArchive</a></code>.  <a href="structmadness_1_1archive_1_1ArchivePrePostImpl_3_01TextFstreamInputArchive_00_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1ArchivePrePostImpl_3_01TextFstreamOutputArchive_00_01T_01_4.html">madness::archive::ArchivePrePostImpl&lt; TextFstreamOutputArchive, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement pre/postamble storage routines for a <code><a class="el" href="classmadness_1_1archive_1_1TextFstreamOutputArchive.html" title="Wraps an archive around a text filestream for output.">TextFstreamOutputArchive</a></code>.  <a href="structmadness_1_1archive_1_1ArchivePrePostImpl_3_01TextFstreamOutputArchive_00_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1ArchiveSerializeImpl.html">madness::archive::ArchiveSerializeImpl&lt; Archive, T, Enabler &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default symmetric serialization of a non-fundamental type that has <code>serialize</code> method.  <a href="structmadness_1_1archive_1_1ArchiveSerializeImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1ArchiveSerializeImpl_3_01Archive_00_01resT_07_5_08_07paramT_8_8_8_08c894ccce70f9e6fa1f873f89b0bb5eb2.html">madness::archive::ArchiveSerializeImpl&lt; Archive, resT(*)(paramT...), std::enable_if_t&lt;!is_default_serializable_v&lt; Archive, resT(*)(paramT...)&gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a function pointer.  <a href="structmadness_1_1archive_1_1ArchiveSerializeImpl_3_01Archive_00_01resT_07_5_08_07paramT_8_8_8_08c894ccce70f9e6fa1f873f89b0bb5eb2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1ArchiveSerializeImpl_3_01Archive_00_01resT_07objT_1_1_5_08_07paramT_108b93756a3299089c3df9a49335dd91.html">madness::archive::ArchiveSerializeImpl&lt; Archive, resT(objT::*)(paramT...) const, std::enable_if_t&lt;!is_default_serializable_v&lt; Archive, resT(objT::*)(paramT...) const &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a const member function pointer.  <a href="structmadness_1_1archive_1_1ArchiveSerializeImpl_3_01Archive_00_01resT_07objT_1_1_5_08_07paramT_108b93756a3299089c3df9a49335dd91.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1ArchiveSerializeImpl_3_01Archive_00_01resT_07objT_1_1_5_08_07paramT_7348625a2fc12f02a33253d05776b147.html">madness::archive::ArchiveSerializeImpl&lt; Archive, resT(objT::*)(paramT...), std::enable_if_t&lt;!is_default_serializable_v&lt; Archive, resT(objT::*)(paramT...)&gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a member function pointer.  <a href="structmadness_1_1archive_1_1ArchiveSerializeImpl_3_01Archive_00_01resT_07objT_1_1_5_08_07paramT_7348625a2fc12f02a33253d05776b147.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1ArchiveSerializeImpl_3_01Archive_00_01std_1_1optional_3_01T_01_4_00_ecab5d8f0676b7d25ef3d39dde00321a.html">madness::archive::ArchiveSerializeImpl&lt; Archive, std::optional&lt; T &gt;, std::enable_if_t&lt; is_serializable_v&lt; Archive, T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize (deserialize) an std::optional.  <a href="structmadness_1_1archive_1_1ArchiveSerializeImpl_3_01Archive_00_01std_1_1optional_3_01T_01_4_00_ecab5d8f0676b7d25ef3d39dde00321a.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1ArchiveSerializeImpl_3_01Archive_00_01std_1_1pair_3_01T_00_01Q_01_4_d593d2e9da6bad77a5b8c764238a74d6.html">madness::archive::ArchiveSerializeImpl&lt; Archive, std::pair&lt; T, Q &gt;, std::enable_if_t&lt; is_serializable_v&lt; Archive, T &gt; &amp;&amp;is_serializable_v&lt; Archive, Q &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize (deserialize) an std::pair.  <a href="structmadness_1_1archive_1_1ArchiveSerializeImpl_3_01Archive_00_01std_1_1pair_3_01T_00_01Q_01_4_d593d2e9da6bad77a5b8c764238a74d6.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1ArchiveSerializeImpl_3_01Archive_00_01std_1_1tuple_3_01Types_8_8_8_085d77da9a856712c84b5bf895e41d103.html">madness::archive::ArchiveSerializeImpl&lt; Archive, std::tuple&lt; Types... &gt;, std::enable_if_t&lt;(is_serializable_v&lt; Archive, Types &gt; &amp;&amp;...) &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize (deserialize) a std::tuple.  <a href="structmadness_1_1archive_1_1ArchiveSerializeImpl_3_01Archive_00_01std_1_1tuple_3_01Types_8_8_8_085d77da9a856712c84b5bf895e41d103.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1ArchiveStoreImpl.html">madness::archive::ArchiveStoreImpl&lt; Archive, T, Enabler &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default store of an object via <code>serialize(ar, t)</code>.  <a href="structmadness_1_1archive_1_1ArchiveStoreImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1ArchiveStoreImpl_3_01Archive_00_01std_1_1allocator_3_01T_01_4_00_01s9ce1b1d92c0373d2832745b797dcfe2f.html">madness::archive::ArchiveStoreImpl&lt; Archive, std::allocator&lt; T &gt;, std::enable_if_t&lt;!is_future&lt; T &gt;::value &amp;&amp;is_serializable_v&lt; Archive, T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a <code>std::allocator</code>.  <a href="structmadness_1_1archive_1_1ArchiveStoreImpl_3_01Archive_00_01std_1_1allocator_3_01T_01_4_00_01s9ce1b1d92c0373d2832745b797dcfe2f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1ArchiveStoreImpl_3_01Archive_00_01std_1_1array_3_01T_00_01N_01_4_00_025d25ce34f54c068554638ebaba1c6b.html">madness::archive::ArchiveStoreImpl&lt; Archive, std::array&lt; T, N &gt;, std::enable_if_t&lt; is_serializable_v&lt; Archive, T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a <code>std::array</code>.  <a href="structmadness_1_1archive_1_1ArchiveStoreImpl_3_01Archive_00_01std_1_1array_3_01T_00_01N_01_4_00_025d25ce34f54c068554638ebaba1c6b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1ArchiveStoreImpl_3_01Archive_00_01std_1_1complex_3_01T_01_4_00_01stdec385ae33369ac90861b3fc0294a2bca.html">madness::archive::ArchiveStoreImpl&lt; Archive, std::complex&lt; T &gt;, std::enable_if_t&lt; is_serializable_v&lt; Archive, T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a complex number.  <a href="structmadness_1_1archive_1_1ArchiveStoreImpl_3_01Archive_00_01std_1_1complex_3_01T_01_4_00_01stdec385ae33369ac90861b3fc0294a2bca.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1ArchiveStoreImpl_3_01Archive_00_01std_1_1list_3_01T_00_01Alloc_01_4_21f0cf3376ef1e3951b65962b1146cfb.html">madness::archive::ArchiveStoreImpl&lt; Archive, std::list&lt; T, Alloc &gt;, std::enable_if_t&lt;!is_future&lt; T &gt;::value &amp;&amp;is_serializable_v&lt; Archive, T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a <code>std::list</code>.  <a href="structmadness_1_1archive_1_1ArchiveStoreImpl_3_01Archive_00_01std_1_1list_3_01T_00_01Alloc_01_4_21f0cf3376ef1e3951b65962b1146cfb.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1ArchiveStoreImpl_3_01Archive_00_01std_1_1map_3_01T_00_01Q_00_01Compaeb362968c6201192509dc6d31e9789cd.html">madness::archive::ArchiveStoreImpl&lt; Archive, std::map&lt; T, Q, Compare, Alloc &gt;, std::enable_if_t&lt; is_serializable_v&lt; Archive, T &gt; &amp;&amp;is_serializable_v&lt; Archive, Q &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize an <code>std::map</code>.  <a href="structmadness_1_1archive_1_1ArchiveStoreImpl_3_01Archive_00_01std_1_1map_3_01T_00_01Q_00_01Compaeb362968c6201192509dc6d31e9789cd.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1ArchiveStoreImpl_3_01Archive_00_01std_1_1set_3_01T_00_01Compare_00_0d0cf71a88a1987af68f489028cabdf5c.html">madness::archive::ArchiveStoreImpl&lt; Archive, std::set&lt; T, Compare, Alloc &gt;, std::enable_if_t&lt;!is_future&lt; T &gt;::value &amp;&amp;is_serializable_v&lt; Archive, T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a <code>std::set</code>.  <a href="structmadness_1_1archive_1_1ArchiveStoreImpl_3_01Archive_00_01std_1_1set_3_01T_00_01Compare_00_0d0cf71a88a1987af68f489028cabdf5c.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1ArchiveStoreImpl_3_01Archive_00_01std_1_1string_01_4.html">madness::archive::ArchiveStoreImpl&lt; Archive, std::string &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a 'std::string'.  <a href="structmadness_1_1archive_1_1ArchiveStoreImpl_3_01Archive_00_01std_1_1string_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1ArchiveStoreImpl_3_01Archive_00_01std_1_1vector_3_01bool_00_01Alloc_01_4_01_4.html">madness::archive::ArchiveStoreImpl&lt; Archive, std::vector&lt; bool, Alloc &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a <code>std::vector&lt;bool&gt;</code> (as a plain array of bool).  <a href="structmadness_1_1archive_1_1ArchiveStoreImpl_3_01Archive_00_01std_1_1vector_3_01bool_00_01Alloc_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmadness_1_1archive_1_1ArchiveStoreImpl_3_01Archive_00_01std_1_1vector_3_01T_00_01Alloc_01_a245403cbe22472b5420793d456ba264.html">madness::archive::ArchiveStoreImpl&lt; Archive, std::vector&lt; T, Alloc &gt;, std::enable_if_t&lt;!is_future&lt; T &gt;::value &amp;&amp;is_serializable_v&lt; Archive, T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a <code>std::vector</code>.  <a href="structmadness_1_1archive_1_1ArchiveStoreImpl_3_01Archive_00_01std_1_1vector_3_01T_00_01Alloc_01_a245403cbe22472b5420793d456ba264.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmadness_1_1archive_1_1BaseArchive.html">madness::archive::BaseArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all archive classes.  <a href="classmadness_1_1archive_1_1BaseArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmadness_1_1archive_1_1BaseInputArchive.html">madness::archive::BaseInputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for input archive classes.  <a href="classmadness_1_1archive_1_1BaseInputArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmadness_1_1archive_1_1BaseOutputArchive.html">madness::archive::BaseOutputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for output archive classes.  <a href="classmadness_1_1archive_1_1BaseOutputArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmadness_1_1archive_1_1BaseParallelArchive.html">madness::archive::BaseParallelArchive&lt; Archive &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for input and output parallel archives.  <a href="classmadness_1_1archive_1_1BaseParallelArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmadness_1_1archive_1_1BinaryFstreamInputArchive.html">madness::archive::BinaryFstreamInputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps an archive around a binary filestream for input.  <a href="classmadness_1_1archive_1_1BinaryFstreamInputArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmadness_1_1archive_1_1BinaryFstreamOutputArchive.html">madness::archive::BinaryFstreamOutputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps an archive around a binary filestream for output.  <a href="classmadness_1_1archive_1_1BinaryFstreamOutputArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmadness_1_1archive_1_1BufferInputArchive.html">madness::archive::BufferInputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps an archive around a memory buffer for input.  <a href="classmadness_1_1archive_1_1BufferInputArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmadness_1_1archive_1_1BufferOutputArchive.html">madness::archive::BufferOutputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps an archive around a memory buffer for output.  <a href="classmadness_1_1archive_1_1BufferOutputArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmadness_1_1archive_1_1MPIInputArchive.html">madness::archive::MPIInputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Archive allowing buffering, deserialization of data, and point-to-point communication between processes with MPI.  <a href="classmadness_1_1archive_1_1MPIInputArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmadness_1_1archive_1_1MPIOutputArchive.html">madness::archive::MPIOutputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Archive allowing buffering, serialization of data, and point-to-point communication between processes with MPI.  <a href="classmadness_1_1archive_1_1MPIOutputArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmadness_1_1archive_1_1MPIRawInputArchive.html">madness::archive::MPIRawInputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Archive allowing deserialization and point-to-point communication between processes with MPI.  <a href="classmadness_1_1archive_1_1MPIRawInputArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmadness_1_1archive_1_1MPIRawOutputArchive.html">madness::archive::MPIRawOutputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Archive allowing serialization and point-to-point communication between processes with MPI.  <a href="classmadness_1_1archive_1_1MPIRawOutputArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmadness_1_1archive_1_1ParallelInputArchive.html">madness::archive::ParallelInputArchive&lt; localarchiveT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An archive for storing local or parallel data, wrapping a <code><a class="el" href="classmadness_1_1archive_1_1BinaryFstreamInputArchive.html" title="Wraps an archive around a binary filestream for input.">BinaryFstreamInputArchive</a></code>.  <a href="classmadness_1_1archive_1_1ParallelInputArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmadness_1_1archive_1_1ParallelOutputArchive.html">madness::archive::ParallelOutputArchive&lt; localarchiveT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An archive for storing local or parallel data wrapping a <code><a class="el" href="classmadness_1_1archive_1_1BinaryFstreamOutputArchive.html" title="Wraps an archive around a binary filestream for output.">BinaryFstreamOutputArchive</a></code>.  <a href="classmadness_1_1archive_1_1ParallelOutputArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmadness_1_1archive_1_1ParallelSerializableObject.html">madness::archive::ParallelSerializableObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Objects that implement their own parallel archive interface should derive from this class.  <a href="classmadness_1_1archive_1_1ParallelSerializableObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmadness_1_1archive_1_1TextFstreamInputArchive.html">madness::archive::TextFstreamInputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps an archive around a text filestream for input.  <a href="classmadness_1_1archive_1_1TextFstreamInputArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmadness_1_1archive_1_1TextFstreamOutputArchive.html">madness::archive::TextFstreamOutputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps an archive around a text filestream for output.  <a href="classmadness_1_1archive_1_1TextFstreamOutputArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmadness_1_1archive_1_1VectorInputArchive.html">madness::archive::VectorInputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps an archive around an STL <code>vector</code> for input.  <a href="classmadness_1_1archive_1_1VectorInputArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmadness_1_1archive_1_1VectorOutputArchive.html">madness::archive::VectorOutputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps an archive around an STL <code>vector</code> for output.  <a href="classmadness_1_1archive_1_1VectorOutputArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga53f401186c8b7dc91e2b9a30d900caea"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serialization.html#ga53f401186c8b7dc91e2b9a30d900caea">ARCHIVE_REGISTER_TYPE</a>(<a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a>,  cooky)</td></tr>
<tr class="memdesc:ga53f401186c8b7dc91e2b9a30d900caea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to associate a type with a cookie value inside archive.  <a href="group__serialization.html#ga53f401186c8b7dc91e2b9a30d900caea">More...</a><br /></td></tr>
<tr class="separator:ga53f401186c8b7dc91e2b9a30d900caea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcb8322c20c49f8f15cb63dd02272f7a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serialization.html#gadcb8322c20c49f8f15cb63dd02272f7a">ARCHIVE_REGISTER_TYPE_AND_PTR</a>(<a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a>,  cooky)</td></tr>
<tr class="memdesc:gadcb8322c20c49f8f15cb63dd02272f7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to associate a type and a pointer to the type with a cookie value inside archive.  <a href="group__serialization.html#gadcb8322c20c49f8f15cb63dd02272f7a">More...</a><br /></td></tr>
<tr class="separator:gadcb8322c20c49f8f15cb63dd02272f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b36a16c962867eb666fc85a1cf7f9c9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serialization.html#ga2b36a16c962867eb666fc85a1cf7f9c9">ARCHIVE_REGISTER_TYPE_AND_PTR_NAMES</a>(<a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a>)</td></tr>
<tr class="memdesc:ga2b36a16c962867eb666fc85a1cf7f9c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to associate names with types and pointers to that type.  <a href="group__serialization.html#ga2b36a16c962867eb666fc85a1cf7f9c9">More...</a><br /></td></tr>
<tr class="separator:ga2b36a16c962867eb666fc85a1cf7f9c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08c0dac29ed921c052de2d8d81b40248"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serialization.html#ga08c0dac29ed921c052de2d8d81b40248">ARCHIVE_REGISTER_TYPE_NAME</a>(<a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a>)</td></tr>
<tr class="memdesc:ga08c0dac29ed921c052de2d8d81b40248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to associate names with types.  <a href="group__serialization.html#ga08c0dac29ed921c052de2d8d81b40248">More...</a><br /></td></tr>
<tr class="separator:ga08c0dac29ed921c052de2d8d81b40248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga885308c94888c26eb87883517b23bf55"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serialization.html#ga885308c94888c26eb87883517b23bf55">ATI</a>&#160;&#160;&#160;::<a class="el" href="structmadness_1_1archive_1_1archive__typeinfo.html">madness::archive::archive_typeinfo</a></td></tr>
<tr class="memdesc:ga885308c94888c26eb87883517b23bf55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>archive_typeinfo</code>.  <a href="group__serialization.html#ga885308c94888c26eb87883517b23bf55">More...</a><br /></td></tr>
<tr class="separator:ga885308c94888c26eb87883517b23bf55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea909158791869e412489f94e406bf49"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serialization.html#gaea909158791869e412489f94e406bf49">ATN</a>&#160;&#160;&#160;::<a class="el" href="group__serialization.html#ga12c36be07f53936d8db1c44d13efb4e4">madness::archive::archive_type_names</a></td></tr>
<tr class="memdesc:gaea909158791869e412489f94e406bf49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>archive_type_names</code>.  <a href="group__serialization.html#gaea909158791869e412489f94e406bf49">More...</a><br /></td></tr>
<tr class="separator:gaea909158791869e412489f94e406bf49"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf3d4f9147ced86b64d73c032c0c65069"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serialization.html#gaf3d4f9147ced86b64d73c032c0c65069">madness::archive::archive_initialize_type_names</a> ()</td></tr>
<tr class="memdesc:gaf3d4f9147ced86b64d73c032c0c65069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the type names for the archives.  <a href="group__serialization.html#gaf3d4f9147ced86b64d73c032c0c65069">More...</a><br /></td></tr>
<tr class="separator:gaf3d4f9147ced86b64d73c032c0c65069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga282ea7f5c2547f45656a8f08608e779d"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:ga282ea7f5c2547f45656a8f08608e779d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structmadness_1_1is__default__serializable.html">is_default_serializable</a>&lt; Archive, <a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a> &gt;::value &amp;&amp;<a class="el" href="structmadness_1_1is__archive.html">is_archive</a>&lt; Archive &gt;::value, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__serialization.html#ga282ea7f5c2547f45656a8f08608e779d">madness::archive::default_serialize</a> (const Archive &amp;ar, const <a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a> &amp;t)</td></tr>
<tr class="memdesc:ga282ea7f5c2547f45656a8f08608e779d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redirect <code>serialize(ar, t)</code> to <code>serialize(ar, &amp;t, 1)</code> for fundamental types.  <a href="group__serialization.html#ga282ea7f5c2547f45656a8f08608e779d">More...</a><br /></td></tr>
<tr class="separator:ga282ea7f5c2547f45656a8f08608e779d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0c6f84de43b8f6506844d3c1292cd83"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:gaf0c6f84de43b8f6506844d3c1292cd83"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structmadness_1_1is__output__archive.html">is_output_archive</a>&lt; Archive &gt;::value &amp;&amp;<a class="el" href="structmadness_1_1is__default__serializable.html">is_default_serializable</a>&lt; Archive, <a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a> &gt;::value &amp;&amp;<a class="el" href="namespacemadness.html#a31abd9317898ab3dd95eb05791bf1ed3">is_function_pointer_v</a>&lt; <a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a> &gt;, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__serialization.html#gaf0c6f84de43b8f6506844d3c1292cd83">madness::archive::default_serialize</a> (const Archive &amp;ar, const <a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a> *t, unsigned int n)</td></tr>
<tr class="memdesc:gaf0c6f84de43b8f6506844d3c1292cd83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize an array of fundamental stuff.  <a href="group__serialization.html#gaf0c6f84de43b8f6506844d3c1292cd83">More...</a><br /></td></tr>
<tr class="separator:gaf0c6f84de43b8f6506844d3c1292cd83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b898747855a7bde5119aacb772c1c94"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga2b898747855a7bde5119aacb772c1c94"><td class="memTemplItemLeft" align="right" valign="top">const char *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__serialization.html#ga2b898747855a7bde5119aacb772c1c94">madness::archive::get_type_name</a> ()</td></tr>
<tr class="memdesc:ga2b898747855a7bde5119aacb772c1c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the type, or unknown if not registered.  <a href="group__serialization.html#ga2b898747855a7bde5119aacb772c1c94">More...</a><br /></td></tr>
<tr class="separator:ga2b898747855a7bde5119aacb772c1c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e0cd291eabe01bb7bc09889a423d329"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:ga2e0cd291eabe01bb7bc09889a423d329"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacemadness.html#a8f1c44c6625bd13b28f5a23b6cc5c48d">is_output_archive_v</a>&lt; Archive &gt;, const Archive &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__serialization.html#ga2e0cd291eabe01bb7bc09889a423d329">madness::archive::operator&amp;</a> (const Archive &amp;ar, const <a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a> &amp;t)</td></tr>
<tr class="memdesc:ga2e0cd291eabe01bb7bc09889a423d329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redirect <code>&amp;</code> to <code><a class="el" href="structmadness_1_1archive_1_1ArchiveImpl.html#a798a6bc468d3730f01e58ece630dad8b" title="Store an object sandwiched between its preamble and postamble.">ArchiveImpl::wrap_store</a></code> for output archives.  <a href="group__serialization.html#ga2e0cd291eabe01bb7bc09889a423d329">More...</a><br /></td></tr>
<tr class="separator:ga2e0cd291eabe01bb7bc09889a423d329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7474e47e12536f432163a461d5691ff9"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:ga7474e47e12536f432163a461d5691ff9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacemadness.html#a8f1c44c6625bd13b28f5a23b6cc5c48d">is_output_archive_v</a>&lt; Archive &gt;, const Archive &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__serialization.html#ga7474e47e12536f432163a461d5691ff9">madness::archive::operator&lt;&lt;</a> (const Archive &amp;ar, const <a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a> &amp;t)</td></tr>
<tr class="memdesc:ga7474e47e12536f432163a461d5691ff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redirect <code>&lt;&lt;</code> to <code><a class="el" href="structmadness_1_1archive_1_1ArchiveImpl.html#a798a6bc468d3730f01e58ece630dad8b" title="Store an object sandwiched between its preamble and postamble.">ArchiveImpl::wrap_store</a></code> for output archives.  <a href="group__serialization.html#ga7474e47e12536f432163a461d5691ff9">More...</a><br /></td></tr>
<tr class="separator:ga7474e47e12536f432163a461d5691ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c09de1d0a565902ec76803c803e0ca7"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:ga3c09de1d0a565902ec76803c803e0ca7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacemadness.html#ab8c40925211424866df4b1277348202f">is_input_archive_v</a>&lt; Archive &gt;, const Archive &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__serialization.html#ga3c09de1d0a565902ec76803c803e0ca7">madness::archive::operator&gt;&gt;</a> (const Archive &amp;ar, const <a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a> &amp;t)</td></tr>
<tr class="memdesc:ga3c09de1d0a565902ec76803c803e0ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redirect <code>&gt;&gt;</code> to <code><a class="el" href="structmadness_1_1archive_1_1ArchiveImpl.html#aea1841cb7b5550c3711a86603f937be6" title="Load an object sandwiched between its preamble and postamble.">ArchiveImpl::wrap_load</a></code> for input archives.  <a href="group__serialization.html#ga3c09de1d0a565902ec76803c803e0ca7">More...</a><br /></td></tr>
<tr class="separator:ga3c09de1d0a565902ec76803c803e0ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c6ea354bb54f9ef5a04d4a6826de0b4"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:ga0c6ea354bb54f9ef5a04d4a6826de0b4"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;(!<a class="el" href="structmadness_1_1is__default__serializable.html">is_default_serializable</a>&lt; Archive, <a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a> &gt;::value &amp;&amp;<a class="el" href="namespacemadness.html#ac1f1038d7ee9f150d7504911ac53cd26">has_nonmember_serialize_v</a>&lt; <a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a>, Archive &gt;) &amp;&amp;<a class="el" href="structmadness_1_1is__archive.html">is_archive</a>&lt; Archive &gt;::value, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__serialization.html#ga0c6ea354bb54f9ef5a04d4a6826de0b4">madness::archive::serialize</a> (const Archive &amp;ar, const <a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a> &amp;t)</td></tr>
<tr class="memdesc:ga0c6ea354bb54f9ef5a04d4a6826de0b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redirect <code>serialize(ar,t)</code> to <code><a class="el" href="structmadness_1_1archive_1_1ArchiveSerializeImpl.html" title="Default symmetric serialization of a non-fundamental type that has serialize method.">ArchiveSerializeImpl</a></code> for non-fundamental types.  <a href="group__serialization.html#ga0c6ea354bb54f9ef5a04d4a6826de0b4">More...</a><br /></td></tr>
<tr class="separator:ga0c6ea354bb54f9ef5a04d4a6826de0b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc7ac1dcbcfbca97966e612e0f050a3b"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:gacc7ac1dcbcfbca97966e612e0f050a3b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; ! <a class="el" href="structmadness_1_1is__default__serializable.html">is_default_serializable</a>&lt; Archive, <a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a> &gt;::value &amp;&amp;<a class="el" href="structmadness_1_1is__archive.html">is_archive</a>&lt; Archive &gt;::value, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__serialization.html#gacc7ac1dcbcfbca97966e612e0f050a3b">madness::archive::serialize</a> (const Archive &amp;ar, const <a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a> *t, unsigned int n)</td></tr>
<tr class="memdesc:gacc7ac1dcbcfbca97966e612e0f050a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize (or deserialize) an array of non-fundamental stuff.  <a href="group__serialization.html#gacc7ac1dcbcfbca97966e612e0f050a3b">More...</a><br /></td></tr>
<tr class="separator:gacc7ac1dcbcfbca97966e612e0f050a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81d3778e719b3e2deed3afec2efb07a5"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga81d3778e719b3e2deed3afec2efb07a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmadness_1_1archive_1_1archive__array.html">archive_array</a>&lt; <a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__serialization.html#ga81d3778e719b3e2deed3afec2efb07a5">madness::archive::wrap</a> (const <a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a> *ptr, unsigned int n)</td></tr>
<tr class="memdesc:ga81d3778e719b3e2deed3afec2efb07a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory function to wrap a dynamically allocated pointer as a typed <code><a class="el" href="classmadness_1_1archive_1_1archive__array.html" title="Wrapper for dynamic arrays and pointers.">archive_array</a></code>.  <a href="group__serialization.html#ga81d3778e719b3e2deed3afec2efb07a5">More...</a><br /></td></tr>
<tr class="separator:ga81d3778e719b3e2deed3afec2efb07a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8dabd2ca613f5efe62a36786a929e9b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gac8dabd2ca613f5efe62a36786a929e9b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmadness_1_1archive_1_1archive__array.html">archive_array</a>&lt; unsigned char &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__serialization.html#gac8dabd2ca613f5efe62a36786a929e9b">madness::archive::wrap_opaque</a> (const <a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a> &amp;t)</td></tr>
<tr class="memdesc:gac8dabd2ca613f5efe62a36786a929e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory function to wrap a contiguous scalar as an opaque (<code>uchar</code>) <code><a class="el" href="classmadness_1_1archive_1_1archive__array.html" title="Wrapper for dynamic arrays and pointers.">archive_array</a></code>.  <a href="group__serialization.html#gac8dabd2ca613f5efe62a36786a929e9b">More...</a><br /></td></tr>
<tr class="separator:gac8dabd2ca613f5efe62a36786a929e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e918da0f47cdb003db884e5c012e646"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga0e918da0f47cdb003db884e5c012e646"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmadness_1_1archive_1_1archive__array.html">archive_array</a>&lt; unsigned char &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__serialization.html#ga0e918da0f47cdb003db884e5c012e646">madness::archive::wrap_opaque</a> (const <a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a> *ptr, unsigned int n)</td></tr>
<tr class="memdesc:ga0e918da0f47cdb003db884e5c012e646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory function to wrap a pointer to contiguous data as an opaque (<code>uchar</code>) <code><a class="el" href="classmadness_1_1archive_1_1archive__array.html" title="Wrapper for dynamic arrays and pointers.">archive_array</a></code>.  <a href="group__serialization.html#ga0e918da0f47cdb003db884e5c012e646">More...</a><br /></td></tr>
<tr class="separator:ga0e918da0f47cdb003db884e5c012e646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ef7f1595a8d871e5c2db488a6e89fb2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga7ef7f1595a8d871e5c2db488a6e89fb2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmadness_1_1archive_1_1archive__ptr.html">archive_ptr</a>&lt; <a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__serialization.html#ga7ef7f1595a8d871e5c2db488a6e89fb2">madness::archive::wrap_ptr</a> (<a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a> *<a class="el" href="derivatives_8cc.html#ad2c6983a6c1401bd9cb4dadf4384c3db">p</a>)</td></tr>
<tr class="memdesc:ga7ef7f1595a8d871e5c2db488a6e89fb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for pointers.  <a href="group__serialization.html#ga7ef7f1595a8d871e5c2db488a6e89fb2">More...</a><br /></td></tr>
<tr class="separator:ga7ef7f1595a8d871e5c2db488a6e89fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga12c36be07f53936d8db1c44d13efb4e4"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serialization.html#ga12c36be07f53936d8db1c44d13efb4e4">madness::archive::archive_type_names</a> [256]</td></tr>
<tr class="memdesc:ga12c36be07f53936d8db1c44d13efb4e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of type names for use in archives.  <a href="group__serialization.html#ga12c36be07f53936d8db1c44d13efb4e4">More...</a><br /></td></tr>
<tr class="separator:ga12c36be07f53936d8db1c44d13efb4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">function pointer serialization</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpfbe36fb9ef627086dff20d34ededfa51"></a></p><dl class="section note"><dt>Note</dt><dd>relative function pointers are represented by std::ptrdiff_t , with member function pointers represented by std::array&lt;std::ptrdiff_t, N&gt; (with N=2 on most common platforms, and a type-dependent constant on some (Microsoft))</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>function pointer to serve as the reference for computing relative pointers </dd></dl>
<dl class="section note"><dt>Note</dt><dd>the value returned by this function is a pointer to a non-virtual member function, this helps on the platforms that use the parity to distinguish non-virtual and virtual pointers (e.g. Itanium ABI) </dd></dl>
</td></tr>
<tr class="memitem:ga398a93c69675434004d7f43cde6536eb"><td class="memItemLeft" align="right" valign="top">std::ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serialization.html#ga398a93c69675434004d7f43cde6536eb">madness::archive::fn_ptr_origin</a> ()</td></tr>
<tr class="separator:ga398a93c69675434004d7f43cde6536eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ea9ecb266abacf943ee1fa49f8fdf4b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = std::enable_if_t&lt;std::is_function&lt;T&gt;::value || is_function_pointer&lt;T&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ga3ea9ecb266abacf943ee1fa49f8fdf4b"><td class="memTemplItemLeft" align="right" valign="top">std::ptrdiff_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__serialization.html#ga3ea9ecb266abacf943ee1fa49f8fdf4b">madness::archive::to_rel_fn_ptr</a> (const <a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a> &amp;fn)</td></tr>
<tr class="memdesc:ga3ea9ecb266abacf943ee1fa49f8fdf4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts function or (free or static member) function pointer to the relative function pointer  <a href="group__serialization.html#ga3ea9ecb266abacf943ee1fa49f8fdf4b">More...</a><br /></td></tr>
<tr class="separator:ga3ea9ecb266abacf943ee1fa49f8fdf4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga885cdeeb8995432789586bfb7d2acc3d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = std::enable_if_t&lt;std::is_member_function_pointer&lt;T&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ga885cdeeb8995432789586bfb7d2acc3d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__serialization.html#ga885cdeeb8995432789586bfb7d2acc3d">madness::archive::to_rel_memfn_ptr</a> (const <a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a> &amp;fn)</td></tr>
<tr class="memdesc:ga885cdeeb8995432789586bfb7d2acc3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts nonstatic member function pointer to the relative equivalent  <a href="group__serialization.html#ga885cdeeb8995432789586bfb7d2acc3d">More...</a><br /></td></tr>
<tr class="separator:ga885cdeeb8995432789586bfb7d2acc3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d74acae9d9c28363eee4baa1cd9de48"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = std::enable_if_t&lt;is_function_pointer_v&lt;T&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga7d74acae9d9c28363eee4baa1cd9de48"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__serialization.html#ga7d74acae9d9c28363eee4baa1cd9de48">madness::archive::to_abs_fn_ptr</a> (std::ptrdiff_t rel_fn_ptr)</td></tr>
<tr class="memdesc:ga7d74acae9d9c28363eee4baa1cd9de48"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts relative free or static member function pointer to the absolute function pointer  <a href="group__serialization.html#ga7d74acae9d9c28363eee4baa1cd9de48">More...</a><br /></td></tr>
<tr class="separator:ga7d74acae9d9c28363eee4baa1cd9de48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca91b4a25998438658947a7b837e2375"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N, typename  = std::enable_if_t&lt;std::is_member_function_pointer&lt;std::remove_reference_t&lt;T&gt;&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:gaca91b4a25998438658947a7b837e2375"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__serialization.html#gaca91b4a25998438658947a7b837e2375">madness::archive::to_abs_memfn_ptr</a> (std::array&lt; std::ptrdiff_t, <a class="el" href="testspectralprop_8cc.html#a8494c8528231375ae253ebfce9d71718">N</a> &gt; rel_fn_ptr)</td></tr>
<tr class="memdesc:gaca91b4a25998438658947a7b837e2375"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts relative (nonstatic) member function pointer to the absolute function pointer  <a href="group__serialization.html#gaca91b4a25998438658947a7b837e2375">More...</a><br /></td></tr>
<tr class="separator:gaca91b4a25998438658947a7b837e2375"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The programmer should not need to include madness/world/archive.h directly. Instead, include the header file for the actual archive (binary file, text/xml file, vector in memory, etc.) that is desired.</p>
<dl class="section user"><dt>Background</dt><dd></dd></dl>
<p>The interface and implementation are deliberately modelled, albeit loosely, upon the boost serialization class (thanks boost!). The major differences are that this archive class does <em>not</em> break cycles and does <em>not</em> automatically store unique copies of data referenced by multiple objects. Also, classes are responsbible for managing their own version information. At the lowest level, the interface to an archive also differs to facilitate vectorization and high-bandwidth data transfer. The implementation employs templates that are almost entirely inlined. This should enable low-overhead use of archives in applications, such as interprocess communication.</p>
<dl class="section user"><dt>How to use an archive?</dt><dd></dd></dl>
<p>An archive is a uni-directional stream of typed data to/from disk, memory, or another process. Whether the stream is for input or for output, you can use the <code>&amp;</code> operator to transfer data to/from the stream. If you really want, you can also use the <code>&lt;&lt;</code> or <code>&gt;&gt;</code> for output or input, respectively, but there is no reason to do so. The <code>&amp;</code> operator chains just like <code>&lt;&lt;</code> for <code>cout</code> or <code>&gt;&gt;</code> for <code>cin</code>. You may discover in <code>archive.h</code> other interfaces but you should <em>not</em> use them &mdash; use the &amp; operator! The lower level interfaces will probably not, or only inconsistently, incorporate type information, and may even appear to work when they are not.</p>
<p>Unless type checking has not been implemented by an archive for reasons of efficiency (e.g., message passing) a C-string exception will be thrown on a type-mismatch when deserializing. End-of-file, out-of-memory, and others also generate string exceptions.</p>
<p>Fundamental types (see below), STL complex, vector, strings, pairs and maps, and tensors (int, long, float, double, float_complex, double_complex) all work without you doing anything, as do fixed-dimension arrays of the same (STL allocators are not presently accomodated). For example, </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> finished = <span class="keyword">false</span>;</div>
<div class="line"><span class="keywordtype">int</span> info[3] = {1, 33, 2};</div>
<div class="line">map&lt;int, double&gt; <a class="code" href="tdse4_8cc.html#ac63c8aae13d788421ccbc301126510c2">fred</a>;</div>
<div class="line"><a class="code" href="tdse4_8cc.html#ac63c8aae13d788421ccbc301126510c2">fred</a>[0] = 55.0; <a class="code" href="tdse4_8cc.html#ac63c8aae13d788421ccbc301126510c2">fred</a>[1] = 99.0;</div>
<div class="line"> </div>
<div class="line">BinaryFstreamOutputArchive ar(<span class="stringliteral">&#39;restart.dat&#39;</span>);</div>
<div class="line">ar &amp; <a class="code" href="tdse4_8cc.html#ac63c8aae13d788421ccbc301126510c2">fred</a> &amp; info &amp; finished;</div>
<div class="ttc" id="atdse4_8cc_html_ac63c8aae13d788421ccbc301126510c2"><div class="ttname"><a href="tdse4_8cc.html#ac63c8aae13d788421ccbc301126510c2">fred</a></div><div class="ttdeci">double fred(const coordT &amp;r)</div><div class="ttdef"><b>Definition:</b> tdse4.cc:368</div></div>
</div><!-- fragment --><p> Deserializing is identical, except that you need to use an input archive, c.f., </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> finished;</div>
<div class="line"><span class="keywordtype">int</span> info[3];</div>
<div class="line">map&lt;int, double&gt; <a class="code" href="tdse4_8cc.html#ac63c8aae13d788421ccbc301126510c2">fred</a>;</div>
<div class="line"> </div>
<div class="line">BinaryFstreamInputArchive ar(<span class="stringliteral">&#39;restart.dat&#39;</span>);</div>
<div class="line">ar &amp; <a class="code" href="tdse4_8cc.html#ac63c8aae13d788421ccbc301126510c2">fred</a> &amp; info &amp; finished;</div>
</div><!-- fragment --><p>Variable dimension and dynamically allocated arrays do not have their dimension encoded in their type. The best way to (de)serialize them is to wrap them in an <code><a class="el" href="classmadness_1_1archive_1_1archive__array.html" title="Wrapper for dynamic arrays and pointers.">archive_array</a></code> as follows. </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="nonlinschro_8cc.html#ab725778fe3179d0229a8da4c908bdf61">a</a>[n]; <span class="comment">// n is not known at compile time</span></div>
<div class="line"><span class="keywordtype">double</span> *<a class="code" href="derivatives_8cc.html#ad2c6983a6c1401bd9cb4dadf4384c3db">p</a> = <span class="keyword">new</span> <span class="keywordtype">double</span>[n];</div>
<div class="line">ar &amp; <a class="code" href="group__serialization.html#ga81d3778e719b3e2deed3afec2efb07a5">wrap</a>(<a class="code" href="nonlinschro_8cc.html#ab725778fe3179d0229a8da4c908bdf61">a</a>,n) &amp; <a class="code" href="group__serialization.html#ga81d3778e719b3e2deed3afec2efb07a5">wrap</a>(<a class="code" href="derivatives_8cc.html#ad2c6983a6c1401bd9cb4dadf4384c3db">p</a>,n);</div>
<div class="ttc" id="aderivatives_8cc_html_ad2c6983a6c1401bd9cb4dadf4384c3db"><div class="ttname"><a href="derivatives_8cc.html#ad2c6983a6c1401bd9cb4dadf4384c3db">p</a></div><div class="ttdeci">char * p(char *buf, const char *name, int k, int initial_level, double thresh, int order)</div><div class="ttdef"><b>Definition:</b> derivatives.cc:72</div></div>
<div class="ttc" id="agroup__serialization_html_ga81d3778e719b3e2deed3afec2efb07a5"><div class="ttname"><a href="group__serialization.html#ga81d3778e719b3e2deed3afec2efb07a5">madness::archive::wrap</a></div><div class="ttdeci">archive_array&lt; T &gt; wrap(const T *, unsigned int)</div><div class="ttdoc">Factory function to wrap a dynamically allocated pointer as a typed archive_array.</div><div class="ttdef"><b>Definition:</b> archive.h:913</div></div>
<div class="ttc" id="anonlinschro_8cc_html_ab725778fe3179d0229a8da4c908bdf61"><div class="ttname"><a href="nonlinschro_8cc.html#ab725778fe3179d0229a8da4c908bdf61">a</a></div><div class="ttdeci">static const double a</div><div class="ttdef"><b>Definition:</b> nonlinschro.cc:118</div></div>
</div><!-- fragment --><p> The <code><a class="el" href="group__serialization.html#ga81d3778e719b3e2deed3afec2efb07a5" title="Factory function to wrap a dynamically allocated pointer as a typed archive_array.">wrap()</a></code> function template is a factory function to simplify instantiation of a correctly typed <code><a class="el" href="classmadness_1_1archive_1_1archive__array.html" title="Wrapper for dynamic arrays and pointers.">archive_array</a></code> template. Note that when deserializing, you must have first allocated the array &mdash; the above code can be used for both serializing and deserializing. If you want the memory to be automatically allocated consider using either an STL vector or a madness tensor.</p>
<p>To transfer the actual value of a pointer to a stream (is this really what you want?) then store an <a class="el" href="classmadness_1_1archive_1_1archive__ptr.html" title="Wrapper for an opaque pointer for serialization purposes.">archive_ptr</a> wrapping it. The factory function <code><a class="el" href="group__serialization.html#ga7ef7f1595a8d871e5c2db488a6e89fb2" title="Wrapper for pointers.">wrap_ptr()</a></code> assists in doing this, e.g., here for a function pointer </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> foo();</div>
<div class="line">ar &amp; <a class="code" href="group__serialization.html#ga7ef7f1595a8d871e5c2db488a6e89fb2">wrap_ptr</a>(foo);</div>
<div class="ttc" id="agroup__serialization_html_ga7ef7f1595a8d871e5c2db488a6e89fb2"><div class="ttname"><a href="group__serialization.html#ga7ef7f1595a8d871e5c2db488a6e89fb2">madness::archive::wrap_ptr</a></div><div class="ttdeci">archive_ptr&lt; T &gt; wrap_ptr(T *p)</div><div class="ttdoc">Wrapper for pointers.</div><div class="ttdef"><b>Definition:</b> archive.h:882</div></div>
</div><!-- fragment --><dl class="section user"><dt>User-defined types</dt><dd></dd></dl>
<p>User-defined types require a little more effort. Three cases are distinguished.</p><ul>
<li>symmetric load and store<ul>
<li>intrusive</li>
<li>non-intrusive</li>
</ul>
</li>
<li>non-symmetric load and store</li>
</ul>
<p>We will examine each in turn, but we first need to discuss a little about the implementation.</p>
<p>When transfering an object <code>obj</code> to/from an archive <code>ar</code> with <code>ar &amp; obj</code>, you need to invoke the templated function </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Archive, <span class="keyword">class</span> T&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">const</span> Archive&amp; <a class="code" href="group__serialization.html#ga2e0cd291eabe01bb7bc09889a423d329">operator&amp;</a>(<span class="keyword">const</span> Archive&amp; ar, <a class="code" href="global__functions_8cc.html#a56860e03db33f2cc0575321bfdc01b57">T</a>&amp; obj);</div>
<div class="ttc" id="aglobal__functions_8cc_html_a56860e03db33f2cc0575321bfdc01b57"><div class="ttname"><a href="global__functions_8cc.html#a56860e03db33f2cc0575321bfdc01b57">T</a></div><div class="ttdeci">auto T(World &amp;world, response_space &amp;f) -&gt; response_space</div><div class="ttdef"><b>Definition:</b> global_functions.cc:34</div></div>
<div class="ttc" id="agroup__serialization_html_ga2e0cd291eabe01bb7bc09889a423d329"><div class="ttname"><a href="group__serialization.html#ga2e0cd291eabe01bb7bc09889a423d329">madness::archive::operator&amp;</a></div><div class="ttdeci">std::enable_if_t&lt; is_output_archive_v&lt; Archive &gt;, const Archive &amp; &gt; operator&amp;(const Archive &amp;ar, const T &amp;t)</div><div class="ttdoc">Redirect &amp; to ArchiveImpl::wrap_store for output archives.</div><div class="ttdef"><b>Definition:</b> archive.h:810</div></div>
</div><!-- fragment --><p> that then invokes other templated functions to redirect to input or output streams as appropriate, manage type checking, etc. We would now like to overload the behavior of these functions in order to accomodate your fancy object. However, function templates cannot be partially specialized. Following the technique recommended <a href="http://www.gotw.ca/publications/mill17.htm">here</a> (look for moral#2), each of the templated functions directly calls a member of a templated class. Classes, unlike functions, can be partially specialized, so it is easy to control and predict what is happening. Thus, in order to change the behavior of all archives for an object you just have to provide a partial specialization of the appropriate class(es). Do <em>not</em> overload any of the function templates.</p>
<p><em>Symmetric intrusive method</em></p>
<p>Many classes can use the same code for serializing and deserializing. If such a class can be modified, the cleanest way of enabling serialization is to add a templated method as follows. </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="classA.html">A</a> {</div>
<div class="line">    <span class="keywordtype">float</span> <a class="code" href="nonlinschro_8cc.html#ab725778fe3179d0229a8da4c908bdf61">a</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="DKops_8h.html#a9cf07ffe0eba2906c66f77d22e1edbbe">A</a>(<span class="keywordtype">float</span> <a class="code" href="nonlinschro_8cc.html#ab725778fe3179d0229a8da4c908bdf61">a</a> = 0.0) : <a class="code" href="nonlinschro_8cc.html#ab725778fe3179d0229a8da4c908bdf61">a</a>(<a class="code" href="nonlinschro_8cc.html#ab725778fe3179d0229a8da4c908bdf61">a</a>) {}</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Archive&gt;</div>
<div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__serialization.html#gacc7ac1dcbcfbca97966e612e0f050a3b">serialize</a>(<span class="keyword">const</span> Archive&amp; ar) {</div>
<div class="line">        ar &amp; <a class="code" href="nonlinschro_8cc.html#ab725778fe3179d0229a8da4c908bdf61">a</a>;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="aDKops_8h_html_a9cf07ffe0eba2906c66f77d22e1edbbe"><div class="ttname"><a href="DKops_8h.html#a9cf07ffe0eba2906c66f77d22e1edbbe">A</a></div><div class="ttdeci">real_convolution_3d A(World &amp;world)</div><div class="ttdef"><b>Definition:</b> DKops.h:230</div></div>
<div class="ttc" id="aclassA_html"><div class="ttname"><a href="classA.html">A</a></div><div class="ttdef"><b>Definition:</b> test_ar.cc:118</div></div>
<div class="ttc" id="agroup__serialization_html_gacc7ac1dcbcfbca97966e612e0f050a3b"><div class="ttname"><a href="group__serialization.html#gacc7ac1dcbcfbca97966e612e0f050a3b">madness::archive::serialize</a></div><div class="ttdeci">std::enable_if_t&lt; ! is_default_serializable&lt; Archive, T &gt;::value &amp;&amp;is_archive&lt; Archive &gt;::value, void &gt; serialize(const Archive &amp;ar, const T *t, unsigned int n)</div><div class="ttdoc">Serialize (or deserialize) an array of non-fundamental stuff.</div><div class="ttdef"><b>Definition:</b> archive.h:497</div></div>
</div><!-- fragment --><p><em>Symmetric non-intrusive method</em></p>
<p>If a class with symmetric serialization cannot be modified, then you can define an external class template with the following signature in the <code><a class="el" href="namespacemadness_1_1archive.html" title="Namespace for I/O tools.">madness::archive</a></code> namespace (where <code>Obj</code> is the name of your type). </p><div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacemadness.html">madness</a> {</div>
<div class="line">    <span class="keyword">namespace </span>archive {</div>
<div class="line">        <span class="keyword">template</span> &lt;<span class="keyword">class</span> Archive&gt;</div>
<div class="line">        <span class="keyword">struct </span>ArchiveSerializeImpl&lt;Archive,Obj&gt; {</div>
<div class="line">            <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__serialization.html#gacc7ac1dcbcfbca97966e612e0f050a3b">serialize</a>(<span class="keyword">const</span> Archive&amp; ar, Obj&amp; obj);</div>
<div class="line">        };</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="anamespacemadness_html"><div class="ttname"><a href="namespacemadness.html">madness</a></div><div class="ttdoc">File holds all helper structures necessary for the CC_Operator and CC2 class.</div><div class="ttdef"><b>Definition:</b> DFParameters.h:10</div></div>
</div><!-- fragment --><p>For example, </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="classB.html">B</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">bool</span> <a class="code" href="nonlinschro_8cc.html#a8f5a312161775190357a664a77a831a3">b</a>;</div>
<div class="line">    <a class="code" href="tdse1d_8cc.html#a9491de326f16c5cce8c064fb5098a07b">B</a>(<span class="keywordtype">bool</span> <a class="code" href="nonlinschro_8cc.html#a8f5a312161775190357a664a77a831a3">b</a> = <span class="keyword">false</span>)</div>
<div class="line">        : <a class="code" href="nonlinschro_8cc.html#a8f5a312161775190357a664a77a831a3">b</a>(<a class="code" href="nonlinschro_8cc.html#a8f5a312161775190357a664a77a831a3">b</a>) {};</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespacemadness.html">madness</a> {</div>
<div class="line">    <span class="keyword">namespace </span>archive {</div>
<div class="line">          <span class="keyword">template</span> &lt;<span class="keyword">class</span> Archive&gt;</div>
<div class="line">          <span class="keyword">struct </span>ArchiveSerializeImpl&lt;Archive, <a class="code" href="classB.html">B</a>&gt; {</div>
<div class="line">              <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__serialization.html#gacc7ac1dcbcfbca97966e612e0f050a3b">serialize</a>(<span class="keyword">const</span> Archive&amp; ar, <a class="code" href="classB.html">B</a>&amp; <a class="code" href="nonlinschro_8cc.html#a8f5a312161775190357a664a77a831a3">b</a>) {</div>
<div class="line">                ar &amp; <a class="code" href="nonlinschro_8cc.html#a8f5a312161775190357a664a77a831a3">b</a>.b;</div>
<div class="line">            };</div>
<div class="line">          };</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclassB_html"><div class="ttname"><a href="classB.html">B</a></div><div class="ttdef"><b>Definition:</b> test_ar.cc:141</div></div>
<div class="ttc" id="anonlinschro_8cc_html_a8f5a312161775190357a664a77a831a3"><div class="ttname"><a href="nonlinschro_8cc.html#a8f5a312161775190357a664a77a831a3">b</a></div><div class="ttdeci">static const double b</div><div class="ttdef"><b>Definition:</b> nonlinschro.cc:119</div></div>
<div class="ttc" id="atdse1d_8cc_html_a9491de326f16c5cce8c064fb5098a07b"><div class="ttname"><a href="tdse1d_8cc.html#a9491de326f16c5cce8c064fb5098a07b">B</a></div><div class="ttdeci">Tensor&lt; double &gt; B</div><div class="ttdef"><b>Definition:</b> tdse1d.cc:166</div></div>
</div><!-- fragment --><p><em>Non-symmetric non-intrusive</em></p>
<p>For classes that do not have symmetric (de)serialization you must define separate partial templates for the functions <code>load</code> and <code>store</code> with these signatures and again in the <code><a class="el" href="namespacemadness_1_1archive.html" title="Namespace for I/O tools.">madness::archive</a></code> namespace. </p><div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacemadness.html">madness</a> {</div>
<div class="line">    <span class="keyword">namespace </span>archive {</div>
<div class="line">          <span class="keyword">template</span> &lt;<span class="keyword">class</span> Archive&gt;</div>
<div class="line">          <span class="keyword">struct </span>ArchiveLoadImpl&lt;Archive, Obj&gt; {</div>
<div class="line">             <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacemadness.html#add3fdf4925be333024eab46795bba394">load</a>(<span class="keyword">const</span> Archive&amp; ar, Obj&amp; obj);</div>
<div class="line">          };</div>
<div class="line"> </div>
<div class="line">          <span class="keyword">template</span> &lt;<span class="keyword">class</span> Archive&gt;</div>
<div class="line">          <span class="keyword">struct </span>ArchiveStoreImpl&lt;Archive, Obj&gt; {</div>
<div class="line">             <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> store(<span class="keyword">const</span> Archive&amp; ar, <span class="keyword">const</span> Obj&amp; obj);</div>
<div class="line">          };</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="anamespacemadness_html_add3fdf4925be333024eab46795bba394"><div class="ttname"><a href="namespacemadness.html#add3fdf4925be333024eab46795bba394">madness::load</a></div><div class="ttdeci">void load(Function&lt; T, NDIM &gt; &amp;f, const std::string name)</div><div class="ttdef"><b>Definition:</b> mra.h:2755</div></div>
</div><!-- fragment --><p>First a simple, but artificial example. </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="classC.html">C</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">long</span> <a class="code" href="relops_8cc.html#a8fc6defe4e499b1b9b9c275689e44352">c</a>;</div>
<div class="line">    <a class="code" href="mtxm__gen_8h.html#aaeb113699ebccfb29980ae43d2e19bdd">C</a>(<span class="keywordtype">long</span> <a class="code" href="relops_8cc.html#a8fc6defe4e499b1b9b9c275689e44352">c</a> = 0)</div>
<div class="line">        : <a class="code" href="relops_8cc.html#a8fc6defe4e499b1b9b9c275689e44352">c</a>(<a class="code" href="relops_8cc.html#a8fc6defe4e499b1b9b9c275689e44352">c</a>) {};</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespacemadness.html">madness</a> {</div>
<div class="line">    <span class="keyword">namespace </span>archive {</div>
<div class="line">        <span class="keyword">template</span> &lt;<span class="keyword">class</span> Archive&gt;</div>
<div class="line">          <span class="keyword">struct </span>ArchiveLoadImpl&lt;Archive, <a class="code" href="classC.html">C</a>&gt; {</div>
<div class="line">              <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacemadness.html#add3fdf4925be333024eab46795bba394">load</a>(<span class="keyword">const</span> Archive&amp; ar, <a class="code" href="classC.html">C</a>&amp; <a class="code" href="relops_8cc.html#a8fc6defe4e499b1b9b9c275689e44352">c</a>) {</div>
<div class="line">                ar &amp; <a class="code" href="relops_8cc.html#a8fc6defe4e499b1b9b9c275689e44352">c</a>.c;</div>
<div class="line">            }</div>
<div class="line">        };</div>
<div class="line"> </div>
<div class="line">          <span class="keyword">template</span> &lt;<span class="keyword">class</span> Archive&gt;</div>
<div class="line">          <span class="keyword">struct </span>ArchiveStoreImpl&lt;Archive, <a class="code" href="classC.html">C</a>&gt; {</div>
<div class="line">              <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> store(<span class="keyword">const</span> Archive&amp; ar, <span class="keyword">const</span> <a class="code" href="classC.html">C</a>&amp; <a class="code" href="relops_8cc.html#a8fc6defe4e499b1b9b9c275689e44352">c</a>) {</div>
<div class="line">                ar &amp; <a class="code" href="relops_8cc.html#a8fc6defe4e499b1b9b9c275689e44352">c</a>.c;</div>
<div class="line">            }</div>
<div class="line">          };</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclassC_html"><div class="ttname"><a href="classC.html">C</a></div><div class="ttdef"><b>Definition:</b> test_ar.cc:170</div></div>
<div class="ttc" id="amtxm__gen_8h_html_aaeb113699ebccfb29980ae43d2e19bdd"><div class="ttname"><a href="mtxm__gen_8h.html#aaeb113699ebccfb29980ae43d2e19bdd">C</a></div><div class="ttdeci">JLOOP2 NK jnz KLOOP2 mov C</div><div class="ttdef"><b>Definition:</b> mtxm_gen.h:12</div></div>
<div class="ttc" id="arelops_8cc_html_a8fc6defe4e499b1b9b9c275689e44352"><div class="ttname"><a href="relops_8cc.html#a8fc6defe4e499b1b9b9c275689e44352">c</a></div><div class="ttdeci">static const double c</div><div class="ttdef"><b>Definition:</b> relops.cc:10</div></div>
</div><!-- fragment --><p>Now a more complicated example that genuinely requires asymmetric load and store.First, a class definition for a simple linked list. </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="classlinked__list.html">linked_list</a> {</div>
<div class="line">    <span class="keywordtype">int</span> value;</div>
<div class="line">    <a class="code" href="classlinked__list.html">linked_list</a> *next;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="classlinked__list.html">linked_list</a>(<span class="keywordtype">int</span> value = 0)</div>
<div class="line">        : value(value), next(0) {};</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespacemadness.html#a12614ee5632185f11ce5d7854759e602">append</a>(<span class="keywordtype">int</span> value) {</div>
<div class="line">        <span class="keywordflow">if</span> (next)</div>
<div class="line">            next-&gt;<a class="code" href="classlinked__list.html#a044d7d5ae912a52b6befdef8729bb01c">append</a>(value);</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">            next = <span class="keyword">new</span> <a class="code" href="classlinked__list.html">linked_list</a>(value);</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> set_value(<span class="keywordtype">int</span> val) {</div>
<div class="line">        value = val;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> get_value()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> value;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classlinked__list.html">linked_list</a>* get_next()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> next;</div>
<div class="line">    };</div>
<div class="line">};</div>
<div class="ttc" id="aclasslinked__list_html"><div class="ttname"><a href="classlinked__list.html">linked_list</a></div><div class="ttdef"><b>Definition:</b> test_ar.cc:280</div></div>
<div class="ttc" id="aclasslinked__list_html_a044d7d5ae912a52b6befdef8729bb01c"><div class="ttname"><a href="classlinked__list.html#a044d7d5ae912a52b6befdef8729bb01c">linked_list::append</a></div><div class="ttdeci">void append(int value)</div><div class="ttdef"><b>Definition:</b> test_ar.cc:286</div></div>
<div class="ttc" id="anamespacemadness_html_a12614ee5632185f11ce5d7854759e602"><div class="ttname"><a href="namespacemadness.html#a12614ee5632185f11ce5d7854759e602">madness::append</a></div><div class="ttdeci">std::vector&lt; Function&lt; T, NDIM &gt; &gt; append(const std::vector&lt; Function&lt; T, NDIM &gt; &gt; &amp;lhs, const std::vector&lt; Function&lt; T, NDIM &gt; &gt; &amp;rhs)</div><div class="ttdoc">combine two vectors</div><div class="ttdef"><b>Definition:</b> vmra.h:649</div></div>
</div><!-- fragment --><p> And this is how you (de)serialize it. </p><div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacemadness.html">madness</a> {</div>
<div class="line">    <span class="keyword">namespace </span>archive {</div>
<div class="line">          <span class="keyword">template</span> &lt;<span class="keyword">class</span> Archive&gt;</div>
<div class="line">          <span class="keyword">struct </span>ArchiveStoreImpl&lt;Archive, <a class="code" href="classlinked__list.html">linked_list</a>&gt; {</div>
<div class="line">              <span class="keyword">static</span> <span class="keywordtype">void</span> store(<span class="keyword">const</span> Archive&amp; ar, <span class="keyword">const</span> <a class="code" href="classlinked__list.html">linked_list</a>&amp; <a class="code" href="relops_8cc.html#a8fc6defe4e499b1b9b9c275689e44352">c</a>) {</div>
<div class="line">                    ar &amp; <a class="code" href="relops_8cc.html#a8fc6defe4e499b1b9b9c275689e44352">c</a>.get_value() &amp; bool(<a class="code" href="relops_8cc.html#a8fc6defe4e499b1b9b9c275689e44352">c</a>.get_next());</div>
<div class="line">                    <span class="keywordflow">if</span> (<a class="code" href="relops_8cc.html#a8fc6defe4e499b1b9b9c275689e44352">c</a>.get_next())</div>
<div class="line">                    ar &amp; *<a class="code" href="relops_8cc.html#a8fc6defe4e499b1b9b9c275689e44352">c</a>.get_next();</div>
<div class="line">              }</div>
<div class="line">          };</div>
<div class="line"> </div>
<div class="line">          <span class="keyword">template</span> &lt;<span class="keyword">class</span> Archive&gt;</div>
<div class="line">          <span class="keyword">struct </span>ArchiveLoadImpl&lt;Archive, <a class="code" href="classlinked__list.html">linked_list</a>&gt; {</div>
<div class="line">              <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="namespacemadness.html#add3fdf4925be333024eab46795bba394">load</a>(<span class="keyword">const</span> Archive&amp; ar, <a class="code" href="classlinked__list.html">linked_list</a>&amp; <a class="code" href="relops_8cc.html#a8fc6defe4e499b1b9b9c275689e44352">c</a>) {</div>
<div class="line">                    <span class="keywordtype">int</span> value;</div>
<div class="line">                <span class="keywordtype">bool</span> flag;</div>
<div class="line"> </div>
<div class="line">                    ar &amp; value &amp; flag;</div>
<div class="line">                    <a class="code" href="relops_8cc.html#a8fc6defe4e499b1b9b9c275689e44352">c</a>.set_value(value);</div>
<div class="line">                    <span class="keywordflow">if</span> (flag) {</div>
<div class="line">                        <a class="code" href="relops_8cc.html#a8fc6defe4e499b1b9b9c275689e44352">c</a>.append(0);</div>
<div class="line">                        ar &amp; *<a class="code" href="relops_8cc.html#a8fc6defe4e499b1b9b9c275689e44352">c</a>.get_next();</div>
<div class="line">                    }</div>
<div class="line">              }</div>
<div class="line">          };</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Given the above implementation of a linked list, you can (de)serialize an entire list using a single statement. </p><div class="fragment"><div class="line"><a class="code" href="classlinked__list.html">linked_list</a> list(0);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=1; i&lt;=10; ++i)</div>
<div class="line">    list.append(i);</div>
<div class="line"> </div>
<div class="line">BinaryFstreamOutputArchive ar(<span class="stringliteral">&#39;list.dat&#39;</span>);</div>
<div class="line">ar &amp; list;</div>
</div><!-- fragment --><dl class="section user"><dt>Non-default constructor</dt><dd></dd></dl>
<p>There are various options for objects that do not have a default constructor. The most appealing and totally non-intrusive approach is to define load/store functions for a pointer to the object. Then in the load method you can deserialize all of the information necessary to invoke the constructor and return a pointer to a new object.</p>
<p>Things that you know are contiguously stored in memory and are painful to serialize with full type safety can be serialized by wrapping opaquely as byte streams using the <code><a class="el" href="group__serialization.html#ga0e918da0f47cdb003db884e5c012e646" title="Factory function to wrap a pointer to contiguous data as an opaque (uchar) archive_array.">wrap_opaque()</a></code> interface. However, this should be regarded as a last resort.</p>
<dl class="section user"><dt>Type checking and registering your own types</dt><dd></dd></dl>
<p>To enable type checking for user-defined types you must register them with the system. There are 64 empty slots for user types beginning at cookie=128. Type checked archives (currently all except the MPI archive) store a cookie (byte with value 0-255) with each datum. Unknown (user-defined) types all end up with the same cookie indicating unkown &mdash; i.e., no type checking unless you register.</p>
<p>Two steps are required to register your own types (e.g., here for the types <code>Foo</code> and <code>Bar</code>)</p><ol type="1">
<li>In a header file, after including madness/world/archive.h, associate your types and pointers to them with cookie values. <div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacemadness.html">madness</a> {</div>
<div class="line">    <span class="keyword">namespace </span>archive {</div>
<div class="line">          <a class="code" href="namespacemadness_1_1archive.html#ad1d0c296c7a9953f86f491a545cf2867">ARCHIVE_REGISTER_TYPE_AND_PTR</a>(<a class="code" href="classFoo.html">Foo</a>,128);</div>
<div class="line">          <a class="code" href="namespacemadness_1_1archive.html#ad1d0c296c7a9953f86f491a545cf2867">ARCHIVE_REGISTER_TYPE_AND_PTR</a>(Bar,129);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclassFoo_html"><div class="ttname"><a href="classFoo.html">Foo</a></div><div class="ttdef"><b>Definition:</b> test_future3.cc:37</div></div>
<div class="ttc" id="anamespacemadness_1_1archive_html_ad1d0c296c7a9953f86f491a545cf2867"><div class="ttname"><a href="namespacemadness_1_1archive.html#ad1d0c296c7a9953f86f491a545cf2867">madness::archive::ARCHIVE_REGISTER_TYPE_AND_PTR</a></div><div class="ttdeci">ARCHIVE_REGISTER_TYPE_AND_PTR(A, 128)</div></div>
</div><!-- fragment --></li>
<li>In a single source file containing your initialization routine, register the name of your types as follows <div class="fragment"><div class="line"><a class="code" href="group__serialization.html#ga2b36a16c962867eb666fc85a1cf7f9c9">ARCHIVE_REGISTER_TYPE_AND_PTR_NAMES</a>(<a class="code" href="classFoo.html">Foo</a>);</div>
<div class="line"><a class="code" href="group__serialization.html#ga2b36a16c962867eb666fc85a1cf7f9c9">ARCHIVE_REGISTER_TYPE_AND_PTR_NAMES</a>(Bar);</div>
<div class="ttc" id="agroup__serialization_html_ga2b36a16c962867eb666fc85a1cf7f9c9"><div class="ttname"><a href="group__serialization.html#ga2b36a16c962867eb666fc85a1cf7f9c9">ARCHIVE_REGISTER_TYPE_AND_PTR_NAMES</a></div><div class="ttdeci">#define ARCHIVE_REGISTER_TYPE_AND_PTR_NAMES(T)</div><div class="ttdoc">Used to associate names with types and pointers to that type.</div><div class="ttdef"><b>Definition:</b> archive.h:170</div></div>
</div><!-- fragment --> Have a look at the test in <code>madness/world/test_ar.cc</code> to see things in action.</li>
</ol>
<dl class="section user"><dt>Types of archive</dt><dd></dd></dl>
<p>Presently provided are</p><ul>
<li>madness/world/text_fstream_archive.h &mdash; (text <code>std::fstream</code>) a file in text (XML).</li>
<li>madness/world/binary_fstream_archive.h &mdash; (binary <code>std::fstream</code>) a file in binary.</li>
<li>madness/world/vector_archive.h &mdash; binary in memory using an <code>std::vector&lt;unsigned_char&gt;</code>.</li>
<li>madness/world/buffer_archive.h &mdash; binary in memory buffer (this is rather heavily specialized for internal use, so applications should use a vector instead).</li>
<li>madness/world/mpi_archive.h &mdash; binary stream for point-to-point communication using MPI (non-typesafe for efficiency).</li>
<li>madness/world/parallel_archive.h &mdash; parallel archive to binary file with multiple readers/writers. This is here mostly to support efficient transfer of large <code><a class="el" href="classmadness_1_1WorldContainer.html" title="Makes a distributed container with specified attributes.">WorldContainer</a></code> (madness/world/worlddc.h) and MADNESS <code><a class="el" href="classmadness_1_1Function.html" title="A multiresolution adaptive numerical function.">Function</a></code> (mra/mra.h) objects, though any serializable object can employ it.</li>
</ul>
<p>The buffer and <code>vector</code> archives are bitwise identical to the binary file archive.</p>
<dl class="section user"><dt>Implementing a new archive</dt><dd></dd></dl>
<p>Minimally, an archive must derive from either <code><a class="el" href="classmadness_1_1archive_1_1BaseInputArchive.html" title="Base class for input archive classes.">BaseInputArchive</a></code> or <code><a class="el" href="classmadness_1_1archive_1_1BaseOutputArchive.html" title="Base class for output archive classes.">BaseOutputArchive</a></code> and define for arrays of fundamental types either a <code>load</code> or <code>store</code> method, as appropriate. Additional methods can be provided to manipulate the target stream. Here is a simple, but functional, implementation of a binary file archive. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="archive_8h.html">madness/world/archive.h</a>&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestd.html">std</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>OutputArchive : <span class="keyword">public</span> BaseOutputArchive {</div>
<div class="line">    <span class="keyword">mutable</span> ofstream os;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  OutputArchive(<span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="namespacemadness.html#a11563d3fc57a4ed09bdab1a88f224009">filename</a>)</div>
<div class="line">      : os(<a class="code" href="namespacemadness.html#a11563d3fc57a4ed09bdab1a88f224009">filename</a>, ios_base::binary | ios_base::out | ios_base::trunc)</div>
<div class="line">  {};</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div>
<div class="line">  <span class="keywordtype">void</span> store(<span class="keyword">const</span> <a class="code" href="global__functions_8cc.html#a56860e03db33f2cc0575321bfdc01b57">T</a>* t, <span class="keywordtype">long</span> n)<span class="keyword"> const </span>{</div>
<div class="line">      os.write((<span class="keyword">const</span> <span class="keywordtype">char</span> *) t, n*<span class="keyword">sizeof</span>(<a class="code" href="global__functions_8cc.html#a56860e03db33f2cc0575321bfdc01b57">T</a>));</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>InputArchive : <span class="keyword">public</span> BaseInputArchive {</div>
<div class="line">  <span class="keyword">mutable</span> ifstream is;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  InputArchive(<span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="namespacemadness.html#a11563d3fc57a4ed09bdab1a88f224009">filename</a>)</div>
<div class="line">      : is(<a class="code" href="namespacemadness.html#a11563d3fc57a4ed09bdab1a88f224009">filename</a>, ios_base::binary | ios_base::in)</div>
<div class="line">  {};</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespacemadness.html#add3fdf4925be333024eab46795bba394">load</a>(<a class="code" href="global__functions_8cc.html#a56860e03db33f2cc0575321bfdc01b57">T</a>* t, <span class="keywordtype">long</span> n)<span class="keyword"> const </span>{</div>
<div class="line">      is.read((<span class="keywordtype">char</span> *) t, n*<span class="keyword">sizeof</span>(<a class="code" href="global__functions_8cc.html#a56860e03db33f2cc0575321bfdc01b57">T</a>));</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="ttc" id="aarchive_8h_html"><div class="ttname"><a href="archive_8h.html">archive.h</a></div><div class="ttdoc">Interface templates for the archives (serialization).</div></div>
<div class="ttc" id="anamespacemadness_html_a11563d3fc57a4ed09bdab1a88f224009"><div class="ttname"><a href="namespacemadness.html#a11563d3fc57a4ed09bdab1a88f224009">madness::filename</a></div><div class="ttdeci">static const char * filename</div><div class="ttdef"><b>Definition:</b> legendre.cc:96</div></div>
<div class="ttc" id="anamespacestd_html"><div class="ttname"><a href="namespacestd.html">std</a></div><div class="ttdef"><b>Definition:</b> mraimpl.h:50</div></div>
</div><!-- fragment --> <h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga53f401186c8b7dc91e2b9a30d900caea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53f401186c8b7dc91e2b9a30d900caea">&#9670;&nbsp;</a></span>ARCHIVE_REGISTER_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ARCHIVE_REGISTER_TYPE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cooky&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">        <span class="keyword">template</span> &lt;&gt; \</div>
<div class="line">        struct archive_typeinfo&lt; T &gt; { \</div>
<div class="line">            static <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> cookie = cooky; \</div>
<div class="line">        }</div>
</div><!-- fragment -->
<p>Used to associate a type with a cookie value inside archive. </p>
<p>Makes a specialization of <code>archive_typeinfo</code> for type <code>T</code> that specifies the correct cookie value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>The type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cooky</td><td>The cookie value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadcb8322c20c49f8f15cb63dd02272f7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcb8322c20c49f8f15cb63dd02272f7a">&#9670;&nbsp;</a></span>ARCHIVE_REGISTER_TYPE_AND_PTR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ARCHIVE_REGISTER_TYPE_AND_PTR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cooky&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">        <a class="code" href="group__serialization.html#ga53f401186c8b7dc91e2b9a30d900caea">ARCHIVE_REGISTER_TYPE</a>(<a class="code" href="global__functions_8cc.html#a56860e03db33f2cc0575321bfdc01b57">T</a>, cooky); \</div>
<div class="line">        ARCHIVE_REGISTER_TYPE(<a class="code" href="global__functions_8cc.html#a56860e03db33f2cc0575321bfdc01b57">T</a>*, cooky+64)</div>
<div class="ttc" id="agroup__serialization_html_ga53f401186c8b7dc91e2b9a30d900caea"><div class="ttname"><a href="group__serialization.html#ga53f401186c8b7dc91e2b9a30d900caea">ARCHIVE_REGISTER_TYPE</a></div><div class="ttdeci">#define ARCHIVE_REGISTER_TYPE(T, cooky)</div><div class="ttdoc">Used to associate a type with a cookie value inside archive.</div><div class="ttdef"><b>Definition:</b> archive.h:134</div></div>
</div><!-- fragment -->
<p>Used to associate a type and a pointer to the type with a cookie value inside archive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>The type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cooky</td><td>The cookie value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2b36a16c962867eb666fc85a1cf7f9c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b36a16c962867eb666fc85a1cf7f9c9">&#9670;&nbsp;</a></span>ARCHIVE_REGISTER_TYPE_AND_PTR_NAMES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ARCHIVE_REGISTER_TYPE_AND_PTR_NAMES</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">        <a class="code" href="group__serialization.html#ga08c0dac29ed921c052de2d8d81b40248">ARCHIVE_REGISTER_TYPE_NAME</a>(<a class="code" href="global__functions_8cc.html#a56860e03db33f2cc0575321bfdc01b57">T</a>); \</div>
<div class="line">        ARCHIVE_REGISTER_TYPE_NAME(<a class="code" href="global__functions_8cc.html#a56860e03db33f2cc0575321bfdc01b57">T</a>*)</div>
<div class="ttc" id="agroup__serialization_html_ga08c0dac29ed921c052de2d8d81b40248"><div class="ttname"><a href="group__serialization.html#ga08c0dac29ed921c052de2d8d81b40248">ARCHIVE_REGISTER_TYPE_NAME</a></div><div class="ttdeci">#define ARCHIVE_REGISTER_TYPE_NAME(T)</div><div class="ttdoc">Used to associate names with types.</div><div class="ttdef"><b>Definition:</b> archive.h:159</div></div>
</div><!-- fragment -->
<p>Used to associate names with types and pointers to that type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>The type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga08c0dac29ed921c052de2d8d81b40248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08c0dac29ed921c052de2d8d81b40248">&#9670;&nbsp;</a></span>ARCHIVE_REGISTER_TYPE_NAME</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ARCHIVE_REGISTER_TYPE_NAME</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">        <span class="keywordflow">if</span> (strcmp( <a class="code" href="group__serialization.html#gaea909158791869e412489f94e406bf49">ATN</a>[ATI&lt; T &gt;::cookie], <span class="stringliteral">&quot;invalid&quot;</span>) ) { \</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;archive_register_type_name: slot/cookie already in use! &quot;</span> &lt;&lt; #<a class="code" href="global__functions_8cc.html#a56860e03db33f2cc0575321bfdc01b57">T</a> &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <a class="code" href="group__serialization.html#gaea909158791869e412489f94e406bf49">ATN</a>[ATI&lt; T &gt;::cookie] &lt;&lt; std::endl; \</div>
<div class="line">            MADNESS_EXCEPTION(<span class="stringliteral">&quot;archive_register_type_name: slot/cookie already in use!&quot;</span>, 0); \</div>
<div class="line">         } \</div>
<div class="line">         ATN[ATI&lt; T &gt;::cookie] = #<a class="code" href="global__functions_8cc.html#a56860e03db33f2cc0575321bfdc01b57">T</a></div>
<div class="ttc" id="agroup__serialization_html_gaea909158791869e412489f94e406bf49"><div class="ttname"><a href="group__serialization.html#gaea909158791869e412489f94e406bf49">ATN</a></div><div class="ttdeci">#define ATN</div><div class="ttdoc">Alias for archive_type_names.</div><div class="ttdef"><b>Definition:</b> archive.h:151</div></div>
</div><!-- fragment -->
<p>Used to associate names with types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>The type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga885308c94888c26eb87883517b23bf55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga885308c94888c26eb87883517b23bf55">&#9670;&nbsp;</a></span>ATI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ATI&#160;&#160;&#160;::<a class="el" href="structmadness_1_1archive_1_1archive__typeinfo.html">madness::archive::archive_typeinfo</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for <code>archive_typeinfo</code>. </p>

</div>
</div>
<a id="gaea909158791869e412489f94e406bf49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea909158791869e412489f94e406bf49">&#9670;&nbsp;</a></span>ATN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ATN&#160;&#160;&#160;::<a class="el" href="group__serialization.html#ga12c36be07f53936d8db1c44d13efb4e4">madness::archive::archive_type_names</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for <code>archive_type_names</code>. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaf3d4f9147ced86b64d73c032c0c65069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3d4f9147ced86b64d73c032c0c65069">&#9670;&nbsp;</a></span>archive_initialize_type_names()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void madness::archive::archive_initialize_type_names </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the type names for the archives. </p>

<p class="reference">References <a class="el" href="group__serialization.html#ga2b36a16c962867eb666fc85a1cf7f9c9">ARCHIVE_REGISTER_TYPE_AND_PTR_NAMES</a>, <a class="el" href="group__serialization.html#ga12c36be07f53936d8db1c44d13efb4e4">madness::archive::archive_type_names</a>, and <a class="el" href="namespacemadness.html#a8621cd6ae91a714c06639942d3910342">madness::initialized()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classmadness_1_1archive_1_1BaseArchive.html#a5fd210dcd02611fb16d7744243a4258c">madness::archive::BaseArchive::BaseArchive()</a>, and <a class="el" href="test__ar_8cc.html#a0ddf1224851353fc92bfbff6f499fa97">main()</a>.</p>

</div>
</div>
<a id="ga282ea7f5c2547f45656a8f08608e779d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga282ea7f5c2547f45656a8f08608e779d">&#9670;&nbsp;</a></span>default_serialize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="structmadness_1_1is__default__serializable.html">is_default_serializable</a>&lt;Archive,<a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a>&gt;::value &amp;&amp; <a class="el" href="structmadness_1_1is__archive.html">is_archive</a>&lt;Archive&gt;::value, void&gt; madness::archive::default_serialize </td>
          <td>(</td>
          <td class="paramtype">const Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Redirect <code>serialize(ar, t)</code> to <code>serialize(ar, &amp;t, 1)</code> for fundamental types. </p>
<p>The function only appears (due to <code>enable_if</code>) if <code>T</code> is serializable and <code>Archive</code> is an archive. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Archive</td><td>The archive type. </td></tr>
    <tr><td class="paramname">T</td><td>The data type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ar</td><td>The archive. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The data to be serialized. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="group__serialization.html#gaf0c6f84de43b8f6506844d3c1292cd83">madness::archive::default_serialize()</a>, and <a class="el" href="archive_8h.html#a3708f5515773c1c1ba8d5387a3a276e3">MAD_ARCHIVE_DEBUG</a>.</p>

</div>
</div>
<a id="gaf0c6f84de43b8f6506844d3c1292cd83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0c6f84de43b8f6506844d3c1292cd83">&#9670;&nbsp;</a></span>default_serialize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="structmadness_1_1is__output__archive.html">is_output_archive</a>&lt;Archive&gt;::value &amp;&amp; <a class="el" href="structmadness_1_1is__default__serializable.html">is_default_serializable</a>&lt;Archive,<a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a>&gt;::value &amp;&amp; <a class="el" href="namespacemadness.html#a31abd9317898ab3dd95eb05791bf1ed3">is_function_pointer_v</a>&lt;<a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a>&gt;, void&gt; madness::archive::default_serialize </td>
          <td>(</td>
          <td class="paramtype">const Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a> *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize an array of fundamental stuff. </p>
<p>The function only appears (via <code>enable_if</code>) if <code>T</code> is serializable and <code>Archive</code> is an output archive. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Archive</td><td>The archive type. </td></tr>
    <tr><td class="paramname">T</td><td>The type of data in the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ar</td><td>The archive. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Pointer to the start of the array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of data items to be serialized. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="archive_8h.html#a3708f5515773c1c1ba8d5387a3a276e3">MAD_ARCHIVE_DEBUG</a>, <a class="el" href="group__serialization.html#ga3ea9ecb266abacf943ee1fa49f8fdf4b">madness::archive::to_rel_fn_ptr()</a>, and <a class="el" href="fcwf_8cc.html#a57edb660f6af2c69daa7a808bac60103">transform()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__serialization.html#ga282ea7f5c2547f45656a8f08608e779d">madness::archive::default_serialize()</a>, <a class="el" href="structmadness_1_1archive_1_1ArchiveLoadImpl.html#a098ff985aef27ac0bf6a13cca88c94f2">madness::archive::ArchiveLoadImpl&lt; Archive, T, Enabler &gt;::load()</a>, <a class="el" href="structmadness_1_1archive_1_1ArchiveStoreImpl.html#a85d0d295552b34e89da796ecf86581e0">madness::archive::ArchiveStoreImpl&lt; Archive, T, Enabler &gt;::store()</a>, <a class="el" href="structmadness_1_1archive_1_1ArchiveImpl_3_01Archive_00_01archive__array_3_01T_01_4_01_4.html#ada61ba438fa5a24a272d899cfb275ba6">madness::archive::ArchiveImpl&lt; Archive, archive_array&lt; T &gt; &gt;::wrap_load()</a>, and <a class="el" href="structmadness_1_1archive_1_1ArchiveImpl_3_01Archive_00_01archive__array_3_01T_01_4_01_4.html#aab0eb2d623e354baa83b2bdb4f5991a6">madness::archive::ArchiveImpl&lt; Archive, archive_array&lt; T &gt; &gt;::wrap_store()</a>.</p>

</div>
</div>
<a id="ga398a93c69675434004d7f43cde6536eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga398a93c69675434004d7f43cde6536eb">&#9670;&nbsp;</a></span>fn_ptr_origin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ptrdiff_t madness::archive::fn_ptr_origin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="structmadness_1_1archive_1_1detail_1_1Ref.html#a8ba5c43894f1a1ecb5d49fce70ef3e86">madness::archive::detail::Ref::fn()</a>.</p>

<p class="reference">Referenced by <a class="el" href="test__ar_8cc.html#a0ddf1224851353fc92bfbff6f499fa97">main()</a>, <a class="el" href="group__serialization.html#ga7d74acae9d9c28363eee4baa1cd9de48">madness::archive::to_abs_fn_ptr()</a>, <a class="el" href="group__serialization.html#gaca91b4a25998438658947a7b837e2375">madness::archive::to_abs_memfn_ptr()</a>, <a class="el" href="group__serialization.html#ga3ea9ecb266abacf943ee1fa49f8fdf4b">madness::archive::to_rel_fn_ptr()</a>, and <a class="el" href="group__serialization.html#ga885cdeeb8995432789586bfb7d2acc3d">madness::archive::to_rel_memfn_ptr()</a>.</p>

</div>
</div>
<a id="ga2b898747855a7bde5119aacb772c1c94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b898747855a7bde5119aacb772c1c94">&#9670;&nbsp;</a></span>get_type_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const char* madness::archive::get_type_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name of the type, or unknown if not registered. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The data type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The name of the type. </dd></dl>

<p class="reference">References <a class="el" href="group__serialization.html#ga12c36be07f53936d8db1c44d13efb4e4">madness::archive::archive_type_names</a>.</p>

</div>
</div>
<a id="ga2e0cd291eabe01bb7bc09889a423d329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e0cd291eabe01bb7bc09889a423d329">&#9670;&nbsp;</a></span>operator&amp;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="namespacemadness.html#a8f1c44c6625bd13b28f5a23b6cc5c48d">is_output_archive_v</a>&lt;Archive&gt;, const Archive&amp;&gt; madness::archive::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Redirect <code>&amp;</code> to <code><a class="el" href="structmadness_1_1archive_1_1ArchiveImpl.html#a798a6bc468d3730f01e58ece630dad8b" title="Store an object sandwiched between its preamble and postamble.">ArchiveImpl::wrap_store</a></code> for output archives. </p>
<p>The function only appears (due to <code>enable_if</code>) if <code>Archive</code> is an output archive. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Archive</td><td>The archive type. </td></tr>
    <tr><td class="paramname">T</td><td>The data type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ar</td><td>The archive. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The data. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="structmadness_1_1archive_1_1ArchiveImpl.html#a798a6bc468d3730f01e58ece630dad8b">madness::archive::ArchiveImpl&lt; Archive, T, Enabler &gt;::wrap_store()</a>.</p>

</div>
</div>
<a id="ga7474e47e12536f432163a461d5691ff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7474e47e12536f432163a461d5691ff9">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="namespacemadness.html#a8f1c44c6625bd13b28f5a23b6cc5c48d">is_output_archive_v</a>&lt;Archive&gt;, const Archive&amp;&gt; madness::archive::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Redirect <code>&lt;&lt;</code> to <code><a class="el" href="structmadness_1_1archive_1_1ArchiveImpl.html#a798a6bc468d3730f01e58ece630dad8b" title="Store an object sandwiched between its preamble and postamble.">ArchiveImpl::wrap_store</a></code> for output archives. </p>
<p>The function only appears (due to <code>enable_if</code>) if <code>Archive</code> is an output archive. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Archive</td><td>The archive type. </td></tr>
    <tr><td class="paramname">T</td><td>The data type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ar</td><td>The archive. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The data. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="archive_8h.html#a3708f5515773c1c1ba8d5387a3a276e3">MAD_ARCHIVE_DEBUG</a>, <a class="el" href="structmadness_1_1archive_1_1ArchiveSerializeImpl.html#a115793c27daca41f981ba8c99a601928">madness::archive::ArchiveSerializeImpl&lt; Archive, T, Enabler &gt;::serialize()</a>, and <a class="el" href="global__functions_8cc.html#a56860e03db33f2cc0575321bfdc01b57">T()</a>.</p>

</div>
</div>
<a id="ga3c09de1d0a565902ec76803c803e0ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c09de1d0a565902ec76803c803e0ca7">&#9670;&nbsp;</a></span>operator&gt;&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="namespacemadness.html#ab8c40925211424866df4b1277348202f">is_input_archive_v</a>&lt;Archive&gt;, const Archive&amp;&gt; madness::archive::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">const Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Redirect <code>&gt;&gt;</code> to <code><a class="el" href="structmadness_1_1archive_1_1ArchiveImpl.html#aea1841cb7b5550c3711a86603f937be6" title="Load an object sandwiched between its preamble and postamble.">ArchiveImpl::wrap_load</a></code> for input archives. </p>
<p>The function only appears (due to <code>enable_if</code>) if <code>Archive</code> is an input archive. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Archive</td><td>The archive type. </td></tr>
    <tr><td class="paramname">T</td><td>The data type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ar</td><td>The archive. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The data. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="structmadness_1_1archive_1_1ArchiveImpl.html#aea1841cb7b5550c3711a86603f937be6">madness::archive::ArchiveImpl&lt; Archive, T, Enabler &gt;::wrap_load()</a>.</p>

</div>
</div>
<a id="ga0c6ea354bb54f9ef5a04d4a6826de0b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c6ea354bb54f9ef5a04d4a6826de0b4">&#9670;&nbsp;</a></span>serialize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; (!<a class="el" href="structmadness_1_1is__default__serializable.html">is_default_serializable</a>&lt;Archive,<a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a>&gt;::value &amp;&amp; <a class="el" href="namespacemadness.html#ac1f1038d7ee9f150d7504911ac53cd26">has_nonmember_serialize_v</a>&lt;<a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a>, Archive&gt;) &amp;&amp; <a class="el" href="structmadness_1_1is__archive.html">is_archive</a>&lt;Archive&gt;::value, void &gt; madness::archive::serialize </td>
          <td>(</td>
          <td class="paramtype">const Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Redirect <code>serialize(ar,t)</code> to <code><a class="el" href="structmadness_1_1archive_1_1ArchiveSerializeImpl.html" title="Default symmetric serialization of a non-fundamental type that has serialize method.">ArchiveSerializeImpl</a></code> for non-fundamental types. </p>
<p>The function only appears (due to <code>enable_if</code>) if <code>T</code> is not serializable and <code>Archive</code> is an archive. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Archive</td><td>The archive type. </td></tr>
    <tr><td class="paramname">T</td><td>The data type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ar</td><td>The archive. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The data to be serialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacc7ac1dcbcfbca97966e612e0f050a3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc7ac1dcbcfbca97966e612e0f050a3b">&#9670;&nbsp;</a></span>serialize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; ! <a class="el" href="structmadness_1_1is__default__serializable.html">is_default_serializable</a>&lt;Archive,<a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a>&gt;::value &amp;&amp; <a class="el" href="structmadness_1_1is__archive.html">is_archive</a>&lt;Archive&gt;::value, void&gt; madness::archive::serialize </td>
          <td>(</td>
          <td class="paramtype">const Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a> *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize (or deserialize) an array of non-fundamental stuff. </p>
<p>The function only appears (via <code>enable_if</code>) if <code>T</code> is not serializable and <code>Archive</code> is an archive. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Archive</td><td>The archive type. </td></tr>
    <tr><td class="paramname">T</td><td>The type of data in the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ar</td><td>The archive. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Pointer to the start of the array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of data items to be serialized. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="archive_8h.html#a3708f5515773c1c1ba8d5387a3a276e3">MAD_ARCHIVE_DEBUG</a>.</p>

<p class="reference">Referenced by <a class="el" href="structmadness_1_1archive_1_1ArchiveLoadImpl.html#a098ff985aef27ac0bf6a13cca88c94f2">madness::archive::ArchiveLoadImpl&lt; Archive, T, Enabler &gt;::load()</a>, <a class="el" href="structmadness_1_1archive_1_1ArchiveStoreImpl.html#a85d0d295552b34e89da796ecf86581e0">madness::archive::ArchiveStoreImpl&lt; Archive, T, Enabler &gt;::store()</a>, <a class="el" href="structmadness_1_1archive_1_1ArchiveImpl_3_01Archive_00_01archive__array_3_01T_01_4_01_4.html#ada61ba438fa5a24a272d899cfb275ba6">madness::archive::ArchiveImpl&lt; Archive, archive_array&lt; T &gt; &gt;::wrap_load()</a>, and <a class="el" href="structmadness_1_1archive_1_1ArchiveImpl_3_01Archive_00_01archive__array_3_01T_01_4_01_4.html#aab0eb2d623e354baa83b2bdb4f5991a6">madness::archive::ArchiveImpl&lt; Archive, archive_array&lt; T &gt; &gt;::wrap_store()</a>.</p>

</div>
</div>
<a id="ga7d74acae9d9c28363eee4baa1cd9de48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d74acae9d9c28363eee4baa1cd9de48">&#9670;&nbsp;</a></span>to_abs_fn_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = std::enable_if_t&lt;is_function_pointer_v&lt;T&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a> madness::archive::to_abs_fn_ptr </td>
          <td>(</td>
          <td class="paramtype">std::ptrdiff_t&#160;</td>
          <td class="paramname"><em>rel_fn_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>converts relative free or static member function pointer to the absolute function pointer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fn</td><td>a relative function pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>absolute function pointer </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__serialization.html#ga3ea9ecb266abacf943ee1fa49f8fdf4b" title="converts function or (free or static member) function pointer to the relative function pointer">to_rel_fn_ptr</a> </dd></dl>

<p class="reference">References <a class="el" href="group__serialization.html#ga398a93c69675434004d7f43cde6536eb">madness::archive::fn_ptr_origin()</a>, and <a class="el" href="global__functions_8cc.html#a56860e03db33f2cc0575321bfdc01b57">T()</a>.</p>

<p class="reference">Referenced by <a class="el" href="structmadness_1_1archive_1_1ArchiveSerializeImpl_3_01Archive_00_01resT_07_5_08_07paramT_8_8_8_08c894ccce70f9e6fa1f873f89b0bb5eb2.html#ac3fc5b04c2de5a817324bda7af4d1c32">madness::archive::ArchiveSerializeImpl&lt; Archive, resT(*)(paramT...), std::enable_if_t&lt;!is_default_serializable_v&lt; Archive, resT(*)(paramT...)&gt; &gt; &gt;::serialize()</a>.</p>

</div>
</div>
<a id="gaca91b4a25998438658947a7b837e2375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca91b4a25998438658947a7b837e2375">&#9670;&nbsp;</a></span>to_abs_memfn_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N, typename  = std::enable_if_t&lt;std::is_member_function_pointer&lt;std::remove_reference_t&lt;T&gt;&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto madness::archive::to_abs_memfn_ptr </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; std::ptrdiff_t, <a class="el" href="testspectralprop_8cc.html#a8494c8528231375ae253ebfce9d71718">N</a> &gt;&#160;</td>
          <td class="paramname"><em>rel_fn_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>converts relative (nonstatic) member function pointer to the absolute function pointer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fn</td><td>a relative function pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>absolute function pointer </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__serialization.html#ga885cdeeb8995432789586bfb7d2acc3d" title="converts nonstatic member function pointer to the relative equivalent">to_rel_memfn_ptr</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>see notes in to_rel_memfn_ptr re: Microsoft ABI </dd></dl>

<p class="reference">References <a class="el" href="group__serialization.html#ga398a93c69675434004d7f43cde6536eb">madness::archive::fn_ptr_origin()</a>.</p>

</div>
</div>
<a id="ga3ea9ecb266abacf943ee1fa49f8fdf4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ea9ecb266abacf943ee1fa49f8fdf4b">&#9670;&nbsp;</a></span>to_rel_fn_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = std::enable_if_t&lt;std::is_function&lt;T&gt;::value || is_function_pointer&lt;T&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ptrdiff_t madness::archive::to_rel_fn_ptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a> &amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>converts function or (free or static member) function pointer to the relative function pointer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fn</td><td>a function or function pointer </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="group__serialization.html#ga398a93c69675434004d7f43cde6536eb">madness::archive::fn_ptr_origin()</a>, and <a class="el" href="global__functions_8cc.html#a56860e03db33f2cc0575321bfdc01b57">T()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__serialization.html#gaf0c6f84de43b8f6506844d3c1292cd83">madness::archive::default_serialize()</a>, <a class="el" href="structmadness_1_1archive_1_1ArchiveSerializeImpl_3_01Archive_00_01resT_07_5_08_07paramT_8_8_8_08c894ccce70f9e6fa1f873f89b0bb5eb2.html#a64f248e001b4e825f69256dee549bade">madness::archive::ArchiveSerializeImpl&lt; Archive, resT(*)(paramT...), std::enable_if_t&lt;!is_default_serializable_v&lt; Archive, resT(*)(paramT...)&gt; &gt; &gt;::serialize()</a>, and <a class="el" href="classmadness_1_1AmArg.html#acc2c691c61928d39f024a93bb832a3c5">madness::AmArg::set_func()</a>.</p>

</div>
</div>
<a id="ga885cdeeb8995432789586bfb7d2acc3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga885cdeeb8995432789586bfb7d2acc3d">&#9670;&nbsp;</a></span>to_rel_memfn_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = std::enable_if_t&lt;std::is_member_function_pointer&lt;T&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto madness::archive::to_rel_memfn_ptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a> &amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>converts nonstatic member function pointer to the relative equivalent </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fn</td><td>a member function pointer </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="group__serialization.html#ga398a93c69675434004d7f43cde6536eb">madness::archive::fn_ptr_origin()</a>, and <a class="el" href="global__functions_8cc.html#a56860e03db33f2cc0575321bfdc01b57">T()</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespacemadness_1_1archive.html#gaf0c6f84de43b8f6506844d3c1292cd83">madness::archive::default_serialize()</a>, and <a class="el" href="structmadness_1_1archive_1_1ArchiveSerializeImpl_3_01Archive_00_01resT_07objT_1_1_5_08_07paramT_7348625a2fc12f02a33253d05776b147.html#a1ec51039903773c8520e5dda160c5dde">madness::archive::ArchiveSerializeImpl&lt; Archive, resT(objT::*)(paramT...), std::enable_if_t&lt;!is_default_serializable_v&lt; Archive, resT(objT::*)(paramT...)&gt; &gt; &gt;::serialize()</a>.</p>

</div>
</div>
<a id="ga81d3778e719b3e2deed3afec2efb07a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81d3778e719b3e2deed3afec2efb07a5">&#9670;&nbsp;</a></span>wrap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmadness_1_1archive_1_1archive__array.html">archive_array</a>&lt; <a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a> &gt; madness::archive::wrap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory function to wrap a dynamically allocated pointer as a typed <code><a class="el" href="classmadness_1_1archive_1_1archive__array.html" title="Wrapper for dynamic arrays and pointers.">archive_array</a></code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The data type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>The pointer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of data elements in the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The wrapped pointer. </dd></dl>

<p class="reference">Referenced by <a class="el" href="structmadness_1_1archive_1_1ArchiveLoadImpl_3_01Archive_00_01Key_3_01NDIM_01_4_01_4.html#a0a8165732bdb1f03ad0e2724e3913ec8">madness::archive::ArchiveLoadImpl&lt; Archive, Key&lt; NDIM &gt; &gt;::load()</a>, <a class="el" href="structmadness_1_1archive_1_1ArchiveLoadImpl_3_01Archive_00_01std_1_1array_3_01T_00_01N_01_4_00_0c286aaa6f2fe5e84dd10b01e3e3fc600.html#a7dd39b104acae29c186f439ae4a95d23">madness::archive::ArchiveLoadImpl&lt; Archive, std::array&lt; T, N &gt;, std::enable_if_t&lt; is_serializable_v&lt; Archive, T &gt; &gt; &gt;::load()</a>, <a class="el" href="structmadness_1_1archive_1_1ArchiveLoadImpl_3_01Archive_00_01std_1_1string_01_4.html#a92b5d144d9aae374bf437c15cfb4b7cc">madness::archive::ArchiveLoadImpl&lt; Archive, std::string &gt;::load()</a>, <a class="el" href="structmadness_1_1archive_1_1ArchiveLoadImpl_3_01Archive_00_01std_1_1vector_3_01bool_00_01Alloc_01_4_01_4.html#a288b13b2a062cb74cc72fb1a4316e43e">madness::archive::ArchiveLoadImpl&lt; Archive, std::vector&lt; bool, Alloc &gt; &gt;::load()</a>, <a class="el" href="structmadness_1_1archive_1_1ArchiveLoadImpl_3_01Archive_00_01std_1_1vector_3_01T_00_01Alloc_01_446482a1a3f2a11a7ba932d35f7dc061b.html#aef0f088ba6d2a5d8e985a87db3283e25">madness::archive::ArchiveLoadImpl&lt; Archive, std::vector&lt; T, Alloc &gt;, std::enable_if_t&lt;!is_future&lt; T &gt;::value &amp;&amp;is_serializable_v&lt; Archive, T &gt; &gt; &gt;::load()</a>, <a class="el" href="structmadness_1_1archive_1_1ArchiveLoadImpl_3_01Archive_00_01GenTensor_3_01T_01_4_01_4.html#ac95ca2900d75b9b8251278d823d0bf2c">madness::archive::ArchiveLoadImpl&lt; Archive, GenTensor&lt; T &gt; &gt;::load()</a>, <a class="el" href="structmadness_1_1archive_1_1ArchiveLoadImpl_3_01Archive_00_01Tensor_3_01T_01_4_01_4.html#a0aba03550157f02e57ce993c7eabd562">madness::archive::ArchiveLoadImpl&lt; Archive, Tensor&lt; T &gt; &gt;::load()</a>, <a class="el" href="structmadness_1_1archive_1_1ArchiveLoadImpl_3_01BinaryFstreamInputArchive_00_01Key_3_01NDIM_01_4_01_4.html#a23c7f34c05af713108e8f219a2975266">madness::archive::ArchiveLoadImpl&lt; BinaryFstreamInputArchive, Key&lt; NDIM &gt; &gt;::load()</a>, <a class="el" href="structInputParameters.html#af9f2cf1569cb0919d8720aa192e5aaf2">InputParameters::serialize()</a>, <a class="el" href="classmadness_1_1KeyChildIterator.html#ae73e86f6309bf4e3028c439b420fd208">madness::KeyChildIterator&lt; NDIM &gt;::serialize()</a>, <a class="el" href="classmadness_1_1SRConf.html#a52548081fdb03d936b5e62d95ed30753">madness::SRConf&lt; T &gt;::serialize()</a>, <a class="el" href="classmadness_1_1TensorTrain.html#aefb5247acc12523c7f040d48b35cb612">madness::TensorTrain&lt; T &gt;::serialize()</a>, <a class="el" href="structmadness_1_1archive_1_1ArchiveStoreImpl_3_01Archive_00_01Key_3_01NDIM_01_4_01_4.html#a144b8c0277aff2fe5b3545dc162bb337">madness::archive::ArchiveStoreImpl&lt; Archive, Key&lt; NDIM &gt; &gt;::store()</a>, <a class="el" href="structmadness_1_1archive_1_1ArchiveStoreImpl_3_01Archive_00_01std_1_1array_3_01T_00_01N_01_4_00_025d25ce34f54c068554638ebaba1c6b.html#ab5e0bda236dd1d20597bf188221b9955">madness::archive::ArchiveStoreImpl&lt; Archive, std::array&lt; T, N &gt;, std::enable_if_t&lt; is_serializable_v&lt; Archive, T &gt; &gt; &gt;::store()</a>, <a class="el" href="structmadness_1_1archive_1_1ArchiveStoreImpl_3_01Archive_00_01std_1_1string_01_4.html#aa0047ac1ec8f4368c5c9a4063eb3d2fd">madness::archive::ArchiveStoreImpl&lt; Archive, std::string &gt;::store()</a>, <a class="el" href="structmadness_1_1archive_1_1ArchiveStoreImpl_3_01Archive_00_01std_1_1vector_3_01bool_00_01Alloc_01_4_01_4.html#a4fe969da117efd93a84eeb709d8db4cb">madness::archive::ArchiveStoreImpl&lt; Archive, std::vector&lt; bool, Alloc &gt; &gt;::store()</a>, <a class="el" href="structmadness_1_1archive_1_1ArchiveStoreImpl_3_01Archive_00_01std_1_1vector_3_01T_00_01Alloc_01_a245403cbe22472b5420793d456ba264.html#af77a9f3504f63aa542fd4cfd29146cc7">madness::archive::ArchiveStoreImpl&lt; Archive, std::vector&lt; T, Alloc &gt;, std::enable_if_t&lt;!is_future&lt; T &gt;::value &amp;&amp;is_serializable_v&lt; Archive, T &gt; &gt; &gt;::store()</a>, <a class="el" href="structmadness_1_1archive_1_1ArchiveStoreImpl_3_01Archive_00_01GenTensor_3_01T_01_4_01_4.html#aaca55b6a8d98524c5460c9b3e47f2d40">madness::archive::ArchiveStoreImpl&lt; Archive, GenTensor&lt; T &gt; &gt;::store()</a>, <a class="el" href="structmadness_1_1archive_1_1ArchiveStoreImpl_3_01Archive_00_01Tensor_3_01T_01_4_01_4.html#a1b912c979efd63d280dbc8afb4fa7ad7">madness::archive::ArchiveStoreImpl&lt; Archive, Tensor&lt; T &gt; &gt;::store()</a>, <a class="el" href="test__ar_8cc.html#a779c0b30172cfeaa8e264de6defa9ac7">test_in()</a>, <a class="el" href="test__ar_8cc.html#a82649ec6534a5a2f8f085b650504a987">test_out()</a>, <a class="el" href="structmadness_1_1archive_1_1ArchiveImpl_3_01Archive_00_01T_0fn_0e_00_01std_1_1enable__if__t_3_9s63db41161ad0bf40e662a0bd8965027e.html#ae2787c498afb7b80b749e9b5447f3dd5">madness::archive::ArchiveImpl&lt; Archive, T[n], std::enable_if_t&lt;!std::is_same_v&lt; T, char &gt; &amp;&amp;is_serializable_v&lt; Archive, T &gt; &gt; &gt;::wrap_load()</a>, <a class="el" href="structmadness_1_1archive_1_1ArchiveImpl_3_01ParallelInputArchive_3_01localarchiveT_01_4_00_01T_0fn_0e_4.html#a20abb474e0d89f1d8e77d639e1721380">madness::archive::ArchiveImpl&lt; ParallelInputArchive&lt; localarchiveT &gt;, T[n]&gt;::wrap_load()</a>, <a class="el" href="structmadness_1_1archive_1_1ArchiveImpl_3_01Archive_00_01T_0fn_0e_00_01std_1_1enable__if__t_3_9s63db41161ad0bf40e662a0bd8965027e.html#a8d681e45028104a9fccdfc868bcd263e">madness::archive::ArchiveImpl&lt; Archive, T[n], std::enable_if_t&lt;!std::is_same_v&lt; T, char &gt; &amp;&amp;is_serializable_v&lt; Archive, T &gt; &gt; &gt;::wrap_store()</a>, and <a class="el" href="structmadness_1_1archive_1_1ArchiveImpl_3_01ParallelOutputArchive_3_01localarchiveT_01_4_00_01T_0fn_0e_4.html#a985ddf73bb96d7a3c1065a2d343b4581">madness::archive::ArchiveImpl&lt; ParallelOutputArchive&lt; localarchiveT &gt;, T[n]&gt;::wrap_store()</a>.</p>

</div>
</div>
<a id="gac8dabd2ca613f5efe62a36786a929e9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8dabd2ca613f5efe62a36786a929e9b">&#9670;&nbsp;</a></span>wrap_opaque() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmadness_1_1archive_1_1archive__array.html">archive_array</a>&lt; unsigned char &gt; madness::archive::wrap_opaque </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory function to wrap a contiguous scalar as an opaque (<code>uchar</code>) <code><a class="el" href="classmadness_1_1archive_1_1archive__array.html" title="Wrapper for dynamic arrays and pointers.">archive_array</a></code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The data type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The wrapped data. </dd></dl>

</div>
</div>
<a id="ga0e918da0f47cdb003db884e5c012e646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e918da0f47cdb003db884e5c012e646">&#9670;&nbsp;</a></span>wrap_opaque() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmadness_1_1archive_1_1archive__array.html">archive_array</a>&lt; unsigned char &gt; madness::archive::wrap_opaque </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory function to wrap a pointer to contiguous data as an opaque (<code>uchar</code>) <code><a class="el" href="classmadness_1_1archive_1_1archive__array.html" title="Wrapper for dynamic arrays and pointers.">archive_array</a></code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The data type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>The pointer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of data elements in the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The wrapped pointer, as an opaque <code><a class="el" href="classmadness_1_1archive_1_1archive__array.html" title="Wrapper for dynamic arrays and pointers.">archive_array</a></code>. </dd></dl>

<p class="reference">References <a class="el" href="global__functions_8cc.html#a56860e03db33f2cc0575321bfdc01b57">T()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classmadness_1_1detail_1_1WorldPtr.html#ab6a384d8f06bb228e1b640ee84b531ca">madness::detail::WorldPtr&lt; T &gt;::load_internal_()</a>, <a class="el" href="structmadness_1_1FunctionImpl_1_1do__op__args.html#a04af1c513abbca753f555011fdfb0f11">madness::FunctionImpl&lt; T, NDIM &gt;::do_op_args&lt; OPDIM &gt;::serialize()</a>, <a class="el" href="classmadness_1_1LBNodeDeux.html#a2b810f6ef374751d759153e13e8d081e">madness::LBNodeDeux&lt; NDIM &gt;::serialize()</a>, <a class="el" href="structmadness_1_1archive_1_1ArchiveSerializeImpl_3_01Archive_00_01resT_07_5_08_07paramT_8_8_8_08c894ccce70f9e6fa1f873f89b0bb5eb2.html#a64f248e001b4e825f69256dee549bade">madness::archive::ArchiveSerializeImpl&lt; Archive, resT(*)(paramT...), std::enable_if_t&lt;!is_default_serializable_v&lt; Archive, resT(*)(paramT...)&gt; &gt; &gt;::serialize()</a>, <a class="el" href="structmadness_1_1archive_1_1ArchiveSerializeImpl_3_01Archive_00_01resT_07objT_1_1_5_08_07paramT_7348625a2fc12f02a33253d05776b147.html#a1ec51039903773c8520e5dda160c5dde">madness::archive::ArchiveSerializeImpl&lt; Archive, resT(objT::*)(paramT...), std::enable_if_t&lt;!is_default_serializable_v&lt; Archive, resT(objT::*)(paramT...)&gt; &gt; &gt;::serialize()</a>, <a class="el" href="classmadness_1_1archive_1_1archive__ptr.html#a897a0f9c52c1b3ae162b19aa9dd3d3c6">madness::archive::archive_ptr&lt; T &gt;::serialize()</a>, <a class="el" href="structmadness_1_1detail_1_1info__base.html#a18bd19ff1edfc4073c7aa20610dd6fe7">madness::detail::info_base&lt; memfunT &gt;::serialize()</a>, <a class="el" href="classmadness_1_1RemoteReference.html#a6815a0e97db5424b898d33f100c9019a">madness::RemoteReference&lt; T &gt;::serialize()</a>, <a class="el" href="structmadness_1_1archive_1_1ArchiveSerializeImpl_3_01Archive_00_01resT_07objT_1_1_5_08_07paramT_108b93756a3299089c3df9a49335dd91.html#ae11097aa0adc073dddf2957860a23665">madness::archive::ArchiveSerializeImpl&lt; Archive, resT(objT::*)(paramT...) const, std::enable_if_t&lt;!is_default_serializable_v&lt; Archive, resT(objT::*)(paramT...) const &gt; &gt; &gt;::serialize()</a>, and <a class="el" href="classmadness_1_1detail_1_1WorldPtr.html#a832ccf7842720ae1b16078b872170f9f">madness::detail::WorldPtr&lt; T &gt;::store_internal_()</a>.</p>

</div>
</div>
<a id="ga7ef7f1595a8d871e5c2db488a6e89fb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ef7f1595a8d871e5c2db488a6e89fb2">&#9670;&nbsp;</a></span>wrap_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmadness_1_1archive_1_1archive__ptr.html">archive_ptr</a>&lt;<a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a>&gt; madness::archive::wrap_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="global__functions_8h.html#adc939c0f0132b4f1fc28d054834a4ea4">T</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper for pointers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of object being pointed to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The wrapped pointer. </dd></dl>

<p class="reference">References <a class="el" href="derivatives_8cc.html#ad2c6983a6c1401bd9cb4dadf4384c3db">p()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga12c36be07f53936d8db1c44d13efb4e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12c36be07f53936d8db1c44d13efb4e4">&#9670;&nbsp;</a></span>archive_type_names</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * madness::archive::archive_type_names</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The list of type names for use in archives. </p>

<p class="reference">Referenced by <a class="el" href="group__serialization.html#gaf3d4f9147ced86b64d73c032c0c65069">madness::archive::archive_initialize_type_names()</a>, <a class="el" href="classmadness_1_1archive_1_1TextFstreamInputArchive.html#a52f924e7569d16f01f8720d4f5466a08">madness::archive::TextFstreamInputArchive::check_start_tag()</a>, <a class="el" href="group__serialization.html#ga2b898747855a7bde5119aacb772c1c94">madness::archive::get_type_name()</a>, <a class="el" href="classmadness_1_1archive_1_1TextFstreamOutputArchive.html#a49f9e64a1d969e02532edba97eefb510">madness::archive::TextFstreamOutputArchive::open()</a>, <a class="el" href="structmadness_1_1archive_1_1ArchivePrePostImpl.html#a4508f5a9926a15ee3b731f41c734c013">madness::archive::ArchivePrePostImpl&lt; Archive, T &gt;::preamble_load()</a>, and <a class="el" href="structmadness_1_1archive_1_1ArchivePrePostImpl.html#af68f987a91b3480c80df9437bca20c57">madness::archive::ArchivePrePostImpl&lt; Archive, T &gt;::preamble_store()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 30 2024 15:11:17 for MADNESS by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
